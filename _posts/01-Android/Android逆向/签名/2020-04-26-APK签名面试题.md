---
date_created: Friday, April 26th 2020, 10:59:03 pm
date_updated: Wednesday, January 22nd 2025, 12:18:22 am
title: APK签名面试题
author: hacket
categories:
  - Android进阶
category: 逆向
tags: [安全, 逆向, 签名, APK]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:40
date updated: 2024-12-24 00:40
aliases: [面试题]
linter-yaml-title-alias: 面试题
---

# 面试题

## APK 组成？和 AAB 的区别？

## Android 中的签名证书和普通的证书区别？

Android 中的签名证书不需要权威机构认证，一般是开发者的自签名证书

## keystore 除了要指定 keystore 文件和密码外，也要指定 alias 和 key 的密码，这是为什么呢？

keystore 是一个**密钥库**，也就是说它可以**存储多对密钥和证书**，keystore 的密码 ` storePassword  ` 是用于保护 keystore 本身的，一对密钥和证书是通过 alias 来区分的。从这里可以看出 jarsigner 是支持使用多个证书对 Apk 进行签名的。apksigner 也同样支持，关于 apksigner 的使用介绍可以参考官方文档 apksigner。

## 签名校验的机制是什么？具体校验的是什么内容吗？

APK 签名是为了保证 APK 的完整性和来源的真实性，分为 JAR 签名和 V2 签名（目前还有 v3、v4）方案。核心思想均是计算 APK 内容的 hash，再使用签名算法对 hash 进行签名。校验时通过签名者公钥解密签名，再与校验者计算的 APK 内容 hash 进行比对，一致则校验通过。

## 申请第三方 SDK（如微信支付）时填入的 SAH1 值是什么？

签名证书的指纹，在申请第三方 SDK 时，需填入 APK 包名和证书指纹，SDK 开发者后台会根据这两个值生成一个 key。第三方 SDK 在初始化时，会从系统中获取当前 APK 的包名、签名证书指纹以及 key，然后将此指纹上传到其服务器，然后校验包名、签名证书指纹是否与此 key 绑定，校验通过后才进行授权。

## 目前众多的快速批量打包方案又是如何绕过签名检验的？

**V1 签名的渠道包方案：**

1. 反编译 APK 后修改渠道值，再重新打包这种方案实际上是重新签名，因有反编译、重新打包、签名的过程，速度相对后两种方案较慢；
2. 将渠道信息以文件形式写入 META-INF 目录中因为 META-INF 目录是用来存放签名的，其本身无法加入签名校验中，在 META-INF 目录中添加文件不会破坏原有签名。此方案需同时修改 zip 数据区、中央目录和中央目录结尾记录；
3. 将渠道信息写到 zip 中央目录结尾记录的 comment 字段中

> 通过分析 zip 文件结构，可以发现中央目录结尾记录最后注释字段，这部分内容在 JAR 签名方案中同样不在签名校验范围中，故添加注释也不会破坏原有签名。此方案只需修改中央目录结尾记录；

4. productFlavor？

**V2 签名的渠道方案：**<br />APK 签名分块中有一个 ID-VALUE 序列， 签名信息（APK 签名方案 v2 分块）只存储在 ID 为 0x7109871a 的 ID-VALUE 中，通过分析签名校验源码可以发现，其它 ID-VALUE 数据是未被解析的，也就是说除 APK 签名方案 v2 分块外，其余 ID-VALUE 是不影响签名校验的。<br />故可以**定义一个新的 ID-VALUE**，将渠道信息写入 APK 签名分块中。因为 V2 方案只保证了第 1、3、4 部分和第 2 部分（APK 签名分块）包含的 APK 签名方案 v2 分块中的 signed data 分块的完整性。新写入的 ID-VALUE 不受保护，Walle 就是这种方案。
