---
banner:
date_created: Sunday, January 4th 2026, 11:29:12 pm
date_updated: Sunday, January 4th 2026, 11:36:35 pm
title: Android 系统手势排除区域
author: hacket
categories:
  - Android
category: Android适配
tags: [Android适配, 屏幕适配]
toc: true
description:
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
aliases: [Android 系统手势排除区域使用指南]
linter-yaml-title-alias: Android 系统手势排除区域使用指南
---

# Android 系统手势排除区域使用指南

## 概述

`setSystemGestureExclusionRects` 是 Android Q (API 29) 引入的 API，用于设置视图中需要优先接收手势输入的区域，避免与系统全面屏手势（如边缘滑动返回）冲突。

## API 信息

- **引入版本**: Android Q (API 29)
- **原生 API**: `View.setSystemGestureExclusionRects(List<Rect>)`
- **兼容版本**: `ViewCompat.setSystemGestureExclusionRects(View, List<Rect>)`

## 使用场景

### ✅ 适用场景

需要在以下情况下使用手势排除区域：

1. **边缘滑动控件**
   - 侧滑抽屉 (NavigationDrawer)
   - 左右滑动切换的 ViewPager/ViewPager2
   - 边缘滑动删除

2. **精细手势操作**
   - SeekBar 拖动条（拇指滑块）
   - 横向 RecyclerView 滑动
   - 自定义滑动手势控件

3. **小区域交互**
   - 需要在 X 或 Y 方向上精确触摸的小区域
   - 边缘的精细拖拽操作

### ❌ 不适用场景

以下情况**不需要**注册排除区域：

1. **大范围滑动区域**
   - ScrollView 的整个区域
   - 普通的全屏列表滑动

2. **简单点击**
   - Button 的点击
   - 普通的 press/release 交互

3. **非边缘区域**
   - 屏幕中央的交互区域
   - 与系统手势不冲突的区域

## 核心注意事项

### 1. 调用时机

**必须**在以下时机调用：
- `onLayout(boolean, int, int, int, int)` 中
- `onDraw(Canvas)` 中
- 或使用 `addOnLayoutChangeListener` 监听布局变化

```kotlin
// ✅ 正确：监听布局变化
view.addOnLayoutChangeListener { v, left, top, right, bottom, _, _, _, _ ->
    val rect = Rect(left, top, right, bottom)
    ViewCompat.setSystemGestureExclusionRects(v, listOf(rect))
}
```

```kotlin
// ❌ 错误：在 onCreate/onViewCreated 等时机调用
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // 此时 view 可能还没有布局，坐标可能不正确
    ViewCompat.setSystemGestureExclusionRects(view, listOf(rect))
}
```

### 2. 垂直高度限制

系统对排除区域的**垂直高度有 200dp 的限制**：

```kotlin
// ⚠️ 注意：垂直方向超过 200dp 的部分会被系统忽略
val rect = Rect(0, 0, 100, 800) // 垂直高度 800dp，只有前 200dp 生效
```

**例外情况**（无高度限制）：
- 导航栏处于 `SYSTEM_UI_FLAG_IMMERSIVE_STICKY` 隐藏状态
- InputMethodService（输入法）
- Home Activity

### 3. 坐标空间

排除区域使用的是 **View 的 post-layout 坐标空间**：

```kotlin
// ✅ 正确：使用相对于 view 自身的坐标
recyclerView.addOnLayoutChangeListener { view, left, top, right, bottom, _, _, _, _ ->
    // left, top, right, bottom 是相对于父容器的坐标
    // 但传递给 systemGestureExclusionRects 时会转换为 view 自身坐标
    val rect = Rect(0, 0, view.width, view.height)
    ViewCompat.setSystemGestureExclusionRects(view, listOf(rect))
}
```

### 4. 系统决策

⚠️ **重要**：设置排除区域是向系统**建议**，不是强制：

- 系统可能选择**放宽**自己的手势识别以允许应用消费手势
- 系统也可能**拒绝**排除请求（取决于系统策略）
- 不同厂商的系统实现可能有差异

## 推荐用法

### 方式一：使用 ViewCompat（推荐）

```kotlin
/**
 * 设置系统手势排除区域
 * 避免全面屏手势返回与控件滑动冲突
 */
private fun setupSystemGestureExclusion(view: View) {
    view.addOnLayoutChangeListener { v, left, top, right, bottom, _, _, _, _ ->
        val rect = Rect(0, 0, v.width, v.height)
        androidx.core.view.ViewCompat.setSystemGestureExclusionRects(v, listOf(rect))
    }
}
```

**优点**：
- 自动处理版本兼容（低于 API 29 自动忽略）
- 代码简洁，无需手动检查版本
- 符合 Android 最佳实践

### 方式二：使用原生 API

```kotlin
private fun setupSystemGestureExclusion(view: View) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        view.addOnLayoutChangeListener { v, left, top, right, bottom, _, _, _, _ ->
            val rect = Rect(0, 0, v.width, v.height)
            v.systemGestureExclusionRects = listOf(rect)
        }
    }
}
```

**缺点**：
- 需要手动检查版本
- 代码冗余

## 实际应用示例

### 示例 1：横向 RecyclerView

```kotlin
class MixPromotionHandler {

    private fun initTopView() {
        topBinding.apply {
            customLayoutManager = CustomLayoutManager(rvMixPromotion.context)
            rvMixPromotion.layoutManager = customLayoutManager
            rvMixPromotion.adapter = listAdapter

            // 设置系统手势排除区域，避免全面屏手势返回冲突
            setupSystemGestureExclusion(rvMixPromotion)
        }
    }

    /**
     * 设置系统手势排除区域
     * 避免全面屏手势返回与顶部横向 RecyclerView 滑动冲突
     */
    private fun setupSystemGestureExclusion(recyclerView: RecyclerView) {
        recyclerView.addOnLayoutChangeListener { view, left, top, right, bottom, _, _, _, _ ->
            val rect = Rect(left, top, right, bottom)
            androidx.core.view.ViewCompat.setSystemGestureExclusionRects(view, listOf(rect))
        }
    }
}
```

### 示例 2：NavigationDrawer 左边缘

```kotlin
class DrawerLayoutHelper {

    private fun setupDrawerGestureExclusion(drawerLayout: DrawerLayout) {
        val drawerView = drawerLayout.findViewById<View>(R.id.nav_drawer)

        drawerView.addOnLayoutChangeListener { view, left, top, right, bottom, _, _, _, _ ->
            // 只排除左侧 50dp 的边缘区域
            val edgeWidth = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                50f,
                view.resources.displayMetrics
            ).toInt()

            val rect = Rect(0, 0, edgeWidth, view.height)
            ViewCompat.setSystemGestureExclusionRects(view, listOf(rect))
        }
    }
}
```

### 示例 3：ViewPager2 边缘滑动

```kotlin
class ViewPagerHelper {

    private fun setupViewPagerGestureExclusion(viewPager: ViewPager2) {
        viewPager.addOnLayoutChangeListener { view, left, top, right, bottom, _, _, _, _ ->
            // 排除左右两侧各 100dp 的区域
            val edgeSize = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                100f,
                view.resources.displayMetrics
            ).toInt()

            val leftRect = Rect(0, 0, edgeSize, view.height)
            val rightRect = Rect(view.width - edgeSize, 0, view.width, view.height)

            ViewCompat.setSystemGestureExclusionRects(view, listOf(leftRect, rightRect))
        }
    }
}
```

### 示例 4：SeekBar 拇指滑块

```kotlin
class CustomSeekBar : View {

    private val thumbRect = Rect()

    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
        super.onLayout(changed, left, top, right, bottom)
        updateThumbRect()
        ViewCompat.setSystemGestureExclusionRects(this, listOf(thumbRect))
    }

    private fun updateThumbRect() {
        // 计算拇指滑块的位置
        val thumbX = (progress / maxProgress.toFloat() * width).toInt()
        thumbRect.set(
            thumbX - thumbRadius,
            0,
            thumbX + thumbRadius,
            height
        )
    }
}
```

## 调试技巧

### 1. 启用系统手势排除区域可视化

在开发者选项中启用 " 显示手势排除区域 "：

```bash
# 通过 adb 启用
adb shell settings put global show_system_gesture_exclusion_rects 1

# 禁用
adb shell settings put global show_system_gesture_exclusion_rects 0
```

启用后，设置的排除区域会在屏幕上以**红色高亮**显示。

### 2. 添加日志验证

```kotlin
private fun setupSystemGestureExclusion(view: View) {
    view.addOnLayoutChangeListener { v, left, top, right, bottom, _, _, _, _ ->
        val rect = Rect(0, 0, v.width, v.height)
        ViewCompat.setSystemGestureExclusionRects(v, listOf(rect))

        // 添加日志验证
        Logger.d("GestureExclusion", "设置排除区域: $rect, view: ${v.javaClass.simpleName}")
    }
}
```

## 常见问题

### Q1: 为什么设置了排除区域但仍然会触发系统返回？

**可能原因**：
1. 垂直高度超过 200dp 限制
2. 在错误的时机调用（view 还未布局）
3. 坐标计算错误
4. 系统选择不接受排除请求（系统策略）

**解决方案**：
- 检查排除区域高度是否 ≤ 200dp
- 使用 `addOnLayoutChangeListener` 确保在布局完成后设置
- 启用可视化调试，检查红色高亮是否正确

### Q2: 是否需要在 Fragment/Activity 销毁时清理？

**答案**：不需要。

`systemGestureExclusionRects` 是 View 的属性，会随着 View 的销毁自动清理。

### Q3: 可以动态更新排除区域吗？

**答案**：可以。

```kotlin
// 动态更新排除区域
fun updateExclusionRect(newRect: Rect) {
    ViewCompat.setSystemGestureExclusionRects(view, listOf(newRect))
}

// 清空排除区域
fun clearExclusionRects() {
    ViewCompat.setSystemGestureExclusionRects(view, emptyList())
}
```

### Q4: 排除区域会影响性能吗？

**答案**：影响极小。

系统手势识别是在系统层面处理，排除区域只是提供元数据给系统，对应用性能影响可忽略。

## 最佳实践总结

1. ✅ **优先使用 `ViewCompat` 兼容版本**
2. ✅ **在 `addOnLayoutChangeListener` 中设置**
3. ✅ **只为真正需要的小区域设置排除**
4. ✅ **注意 200dp 垂直高度限制**
5. ✅ **使用可视化调试验证效果**
6. ❌ **不要为大范围区域设置排除**
7. ❌ **不要在布局前设置坐标**
8. ❌ **不要期望系统一定接受排除请求**

## 相关资源

- [官方文档: View.setSystemGestureExclusionRects](https://developer.android.com/reference/android/view/View#setSystemGestureExclusionRects(java.util.List%3Candroid.graphics.Rect%3E))
- [官方文档: ViewCompat.setSystemGestureExclusionRects](https://developer.android.com/reference/androidx/core/view/ViewCompat#setSystemGestureExclusionRects(android.view.View,java.util.List%3Candroid.graphics.Rect%3E))
- [Gesture navigation: handling visual interruptions](https://developer.android.com/develop/ui/views/layout/edge-to-edge)
