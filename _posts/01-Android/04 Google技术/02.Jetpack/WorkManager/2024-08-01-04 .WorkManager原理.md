---
date_created: Thursday, August 1st 2024, 11:50:43 pm
date_updated: Tuesday, January 21st 2025, 11:49:07 pm
title: 04 .WorkManageråŸç†
author: hacket
categories:
  - Android
category: Jetpack
tags: [Jetpack, WorkManager]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-08-01 23:50
date updated: 2024-12-24 00:32
aliases: [WorkManager æ ¸å¿ƒç»„ä»¶]
linter-yaml-title-alias: WorkManager æ ¸å¿ƒç»„ä»¶
---

# WorkManager æ ¸å¿ƒç»„ä»¶

- **Worker**ï¼šWorker æ˜¯åå°ä»»åŠ¡æ‰§è¡Œçš„ä¸»ä½“ï¼Œç»§æ‰¿è‡ª Worker ç±»å¹¶é‡å†™ doWork() æ–¹æ³•æ¥å®ç°å…·ä½“çš„åå°é€»è¾‘ã€‚
- **WorkRequest**ï¼šå®ƒå®šä¹‰äº†è¦æ‰§è¡Œçš„ä»»åŠ¡ï¼ŒåŒ…æ‹¬å…·ä½“çš„ Worker ç±»ã€æ‰§è¡Œçº¦æŸã€åˆå§‹å»¶è¿Ÿç­‰ã€‚
- **WorkInfo**ï¼šæä¾›äº†å¯¹å·¥ä½œçŠ¶æ€çš„æŸ¥è¯¢ï¼Œå¯ä»¥çŸ¥é“ä»»åŠ¡æ˜¯å¦æˆåŠŸæ‰§è¡Œã€æ˜¯å¦å¤±è´¥ç­‰ã€‚
- **WorkManager**ï¼šæ˜¯æ•´ä¸ªåå°ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿçš„ç®¡ç†è€…ï¼Œè´Ÿè´£å°† WorkRequest è½¬æ¢æˆå†…éƒ¨çš„ WorkSpec å¹¶åŠ å…¥åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ã€‚

![](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NeyRYZFErHogkJPVHgw-eQ.png)

- if API level > 23, Work Manager executes the `Job Scheduler`
- if API level < 23, Work Manager checks the availability of Google Play ServicesÂ _(because some Chinese devices cannot access Google Play Services_ğŸ˜¬_)_Â if NO, it executes Custom Class that is a mix of `Alarm Manager` and `BroadcastReceiver`

# WorkManager å·¥ä½œåŸç†è§£æ

1. **åˆ›å»º**\
   a. WorkManager çš„åˆå§‹åŒ–\
   b. WorkRequest çš„åˆ›å»º
2. **éçº¦æŸæ¡ä»¶ä»»åŠ¡çš„æ‰§è¡Œ**
3. **å¸¦çº¦æŸæ¡ä»¶ä»»åŠ¡çš„æ‰§è¡Œ**

æµ‹è¯•æºç ï¼š

```kotlin
val work1Request = OneTimeWorkRequestBuilder<Worker1>().build()
WorkManager.getInstance(this).enqueue(work1Request)

class Worker1(appContext: Context, workerParams: WorkerParameters) :
    Worker(appContext, workerParams) {

    override fun doWork(): Result {
        Thread.sleep(5000)
        return Result.success()
    }
}
```

## åˆ›å»º

### WorkManager çš„åˆå§‹åŒ–

åœ¨é»˜è®¤çš„æƒ…å†µä¸‹ï¼Œ`WorkManager` å¹¶ä¸æ˜¯åœ¨æˆ‘ä»¬è°ƒç”¨ `WorkManager.getInstance()` æ—¶åˆ›å»ºçš„ã€‚é€šè¿‡åç¼–è¯‘ä¸€ä¸‹ apkï¼Œä¼šå‘ç°åœ¨ `AndroidManifest.xml` æ–‡ä»¶ä¸­æ³¨å†Œäº†åä¸º `WorkManagerInitializer` çš„ `ContentProvider`ã€‚å› æ­¤ `WorkManager` åœ¨ app å†·å¯åŠ¨çš„æ—¶å€™å·²ç»è¢«åˆ›å»ºã€‚

```xml
<!--AndroidManifest.xml-->
<provider
	android:name="androidx.work.impl.WorkManagerInitializer"
	android:exported="false"
	android:multiprocess="true"
	android:authorities="com.jandroid.multivideo.workmanager-init"
	android:directBootAware="false" />
```

`WorkManagerInitializer` ç±»ï¼š

```java
public final class WorkManagerInitializer implements Initializer<WorkManager> {
    private static final String TAG = Logger.tagWithPrefix("WrkMgrInitializer");
    @NonNull
    @Override
    public WorkManager create(@NonNull Context context) {
        // Initialize WorkManager with the default configuration.
        Logger.get().debug(TAG, "Initializing WorkManager with default configuration.");
        WorkManager.initialize(context, new Configuration.Builder().build());
        return WorkManager.getInstance(context);
    }
    @NonNull
    @Override
    public List<Class<? extends androidx.startup.Initializer<?>>> dependencies() {
        return Collections.emptyList();
    }
}
// class WorkManager
public static void initialize(@NonNull Context context, @NonNull Configuration configuration) {  
    WorkManagerImpl.initialize(context, configuration);  
}
```

ç”±äº `WorkManager` æ˜¯ä¸ªå•ä¾‹ï¼Œåœ¨æ­¤æ—¶ `WorkManager` å°±å·²ç»è¢«åˆå§‹åŒ–äº†ã€‚åœ¨ `initialize()` ä¹‹å‰ï¼Œä¼šåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„ `Configuration`ã€‚`Configuration` è®¾ç½®äº†è®¸å¤šå±æ€§ï¼Œç”¨æ¥ç®¡ç†å’Œè°ƒåº¦å·¥ä½œçš„æ–¹å¼ã€‚é€šå¸¸æˆ‘ä»¬ä½¿ç”¨ `WorkManager` é»˜è®¤åˆ›å»ºçš„ `Configuration` å³å¯ã€‚å¦‚éœ€ä½¿ç”¨è‡ªå·±çš„ `Configuration`ï¼Œå¯å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼Œæœ‰æ˜ç¡®çš„ä½¿ç”¨è¯´æ˜ã€‚

ç»§ç»­çœ‹ `initialize()` çš„å®ç°ï¼š

```java
// class WorkManager
public static void initialize(@NonNull Context context, @NonNull Configuration configuration) {  
    WorkManagerImpl.initialize(context, configuration);  
}
// class WorkManagerImpl
private static WorkManagerImpl sDelegatedInstance = null;  
private static WorkManagerImpl sDefaultInstance = null;
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public static void initialize(@NonNull Context context, @NonNull Configuration configuration) {
	synchronized (sLock) {
		if (sDelegatedInstance != null && sDefaultInstance != null) {
			throw new IllegalStateException("WorkManager is already initialized.  Did you "
					+ "try to initialize it manually without disabling "
					+ "WorkManagerInitializer? See "
					+ "WorkManager#initialize(Context, Configuration) or the class level "
					+ "Javadoc for more information.");
		}

		if (sDelegatedInstance == null) {
			context = context.getApplicationContext();
			if (sDefaultInstance == null) {
				sDefaultInstance = new WorkManagerImpl(
						context,
						configuration,
						new WorkManagerTaskExecutor(configuration.getTaskExecutor()));
			}
			sDelegatedInstance = sDefaultInstance;
		}
	}
}
```

æ­¤æ—¶ `sDelegatedInstance` ä¸º `null`ï¼Œ`WorkManager` ä¼šå…ˆåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„ `WorkManagerTaskExecutor` å¯¹è±¡ï¼Œç”¨æ¥æ‰§è¡Œ `WorkManager` çš„ä»»åŠ¡ã€‚ä¹‹ååˆ›å»ºä¸€ä¸ª `WorkManagerImpl` å¯¹è±¡:

```java
public WorkManagerImpl(
	@NonNull Context context,
	@NonNull Configuration configuration,
	@NonNull TaskExecutor workTaskExecutor) {
this(context,
	configuration,
	workTaskExecutor,
	context.getResources().getBoolean(R.bool.workmanager_test_configuration));
}
public WorkManagerImpl(
		@NonNull Context context,
		@NonNull Configuration configuration,
		@NonNull TaskExecutor workTaskExecutor,
		boolean useTestDatabase) {
	this(context,
			configuration,
			workTaskExecutor,
			WorkDatabase.create(
					context.getApplicationContext(),
					workTaskExecutor.getBackgroundExecutor(),
					useTestDatabase)
	);
}
```

`WorkManager` åœ¨æ­¤æ—¶åˆ›å»ºäº†æ•°æ®åº“ã€‚`WorkDatabase.create()` å°†ä»»åŠ¡åˆ—è¡¨åºåˆ—åŒ–åˆ°æœ¬åœ°ï¼Œè®°å½•æ¯ä¸€ä¸ªä»»åŠ¡çš„å±æ€§ï¼Œæ‰§è¡Œæ¡ä»¶ï¼Œæ‰§è¡Œé¡ºåºåŠæ‰§è¡ŒçŠ¶æ€ç­‰ã€‚ä»è€Œä¿è¯ä»»åŠ¡åœ¨å†·å¯åŠ¨æˆ–ç¡¬ä»¶é‡å¯åï¼Œå¯ä»¥æ ¹æ®æ¡ä»¶ç»§ç»­æ‰§è¡Œã€‚

æ¥ç€çœ‹ this() çš„å®ç°:

```java
public WorkManagerImpl(
		@NonNull Context context,
		@NonNull Configuration configuration,
		@NonNull TaskExecutor workTaskExecutor,
		@NonNull WorkDatabase database) {
	Context applicationContext = context.getApplicationContext();
	Logger.setLogger(new Logger.LogcatLogger(configuration.getMinimumLoggingLevel()));
	List<Scheduler> schedulers =
			createSchedulers(applicationContext, configuration, workTaskExecutor);
	Processor processor = new Processor(
			context,
			configuration,
			workTaskExecutor,
			database,
			schedulers);
	internalInit(context, configuration, workTaskExecutor, database, schedulers, processor);
}
```

- `createSchedulers()` æ¥æ ¹æ® Build Version åˆ›å»ºä¸åŒçš„ `Schedulers` è¿›è¡Œä»»åŠ¡è°ƒåº¦
- `Processor()` ç”¨æ¥ç®¡ç† `Schedulers` çš„æ‰§è¡Œ
- `internalInit()` çœŸæ­£çš„åˆå§‹åŒ–

#### Scheduler åˆå§‹åŒ–

å…ˆçœ‹ `WorkManagerImpl.createSchedulers()`ï¼Œè¿”å›ä¸€ä¸ª Scheduler çš„ List

```java
public List<Scheduler> createSchedulers(
		@NonNull Context context,
		@NonNull Configuration configuration,
		@NonNull TaskExecutor taskExecutor) {

	return Arrays.asList(
			Schedulers.createBestAvailableBackgroundScheduler(context, this),
			// Specify the task executor directly here as this happens before internalInit.
			// GreedyScheduler creates ConstraintTrackers and controllers eagerly.
			new GreedyScheduler(context, configuration, taskExecutor, this));
}
```

ç”±æ­¤å¯è§ï¼Œ`WorkManager` åˆ›å»ºäº†ä¸¤ä¸ª `Scheduler`ï¼š

- åˆ†åˆ«ä¸ºæ‰§è¡Œéçº¦æŸéå‘¨æœŸæ€§ä»»åŠ¡çš„ `GreedyScheduler`
- å’Œæ‰§è¡Œçº¦æŸæ€§å‘¨æœŸæ€§ä»»åŠ¡çš„ `SystemJobScheduler` / `GcmBasedScheduler` / `SystemAlarmScheduler`ã€‚

##### GreedyScheduler

`GreedyScheduler()` æ˜¯å¸¸é©»çš„ï¼Œç”¨æ¥æ‰§è¡Œæ²¡æœ‰ä»»ä½•çº¦æŸçš„éå‘¨æœŸæ€§çš„ä»»åŠ¡ã€‚

##### createBestAvailableBackgroundScheduler

æ¥ä¸‹æ¥çœ‹ `createBestAvailableBackgroundScheduler()` çš„å®ç°ã€‚

```java
// Schedulers.java v2.7.1
static Scheduler createBestAvailableBackgroundScheduler(
		@NonNull Context context,
		@NonNull WorkManagerImpl workManager) {

	Scheduler scheduler;

	if (Build.VERSION.SDK_INT >= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL) { // API23
		scheduler = new SystemJobScheduler(context, workManager);
		setComponentEnabled(context, SystemJobService.class, true);
		Logger.get().debug(TAG, "Created SystemJobScheduler and enabled SystemJobService");
	} else {
		scheduler = tryCreateGcmBasedScheduler(context);
		if (scheduler == null) {
			scheduler = new SystemAlarmScheduler(context);
			setComponentEnabled(context, SystemAlarmService.class, true);
			Logger.get().debug(TAG, "Created SystemAlarmScheduler");
		}
	}
	return scheduler;
}
public static final String GCM_SCHEDULER = "androidx.work.impl.background.gcm.GcmScheduler";
@Nullable  
private static Scheduler tryCreateGcmBasedScheduler(@NonNull Context context) {  
    try {  
        Class<?> klass = Class.forName(GCM_SCHEDULER);  
        Scheduler scheduler =  
                (Scheduler) klass.getConstructor(Context.class).newInstance(context);  
        Logger.get().debug(TAG, String.format("Created %s", GCM_SCHEDULER));  
        return scheduler;  
    } catch (Throwable throwable) {  
        Logger.get().debug(TAG, "Unable to create GCM Scheduler", throwable);  
        return null;    }  
}
```

è¿™æ®µä»£ç å¯¹ build version è¿›è¡Œäº†åˆ¤æ–­ã€‚

- `Â >=23`ï¼Œåˆ™è¿”å› `SystemJobScheduler()`ï¼Œå³åˆ©ç”¨ `JobScheduler` è¿›è¡Œä»»åŠ¡ç®¡ç†ã€‚
- `<23` çš„æ—¶å€™å…ˆå°è¯•ä½¿ç”¨ `GcmScheduler` è¿›è¡Œç®¡ç†ã€‚è‹¥æ— æ³•åˆ›å»º `GcmScheduler` åˆ™è¿”å› `SystemAlarmScheduler()` ä½¿ç”¨ `AlamManager` è¿›è¡Œä»»åŠ¡ç®¡ç†ã€‚è¿”å›çš„è¿™ä¸ª `Scheduler` æ˜¯ç”¨æ¥æ‰§è¡Œå‘¨æœŸæ€§ï¼Œæˆ–è€…æœ‰çº¦æŸæ€§çš„ä»»åŠ¡ã€‚

#### Processor

```java
public WorkManagerImpl(
		@NonNull Context context,
		@NonNull Configuration configuration,
		@NonNull TaskExecutor workTaskExecutor,
		@NonNull WorkDatabase database) {
	Context applicationContext = context.getApplicationContext();
	Logger.setLogger(new Logger.LogcatLogger(configuration.getMinimumLoggingLevel()));
	List<Scheduler> schedulers =
			createSchedulers(applicationContext, configuration, workTaskExecutor);
	Processor processor = new Processor(
			context,
			configuration,
			workTaskExecutor,
			database,
			schedulers);
	internalInit(context, configuration, workTaskExecutor, database, schedulers, processor);
}
```

`Processor` å­˜å‚¨äº† `Configuration`ï¼Œ`TaskExecutor`ï¼Œ`WorkDatabase`ï¼Œ`schedulers` ç­‰ï¼Œç”¨æ¥åœ¨é€‚å½“çš„æ—¶æœºè¿›è¡Œä»»åŠ¡è°ƒåº¦ã€‚å†æ¥çœ‹ `internalInit()`:

```java
private void internalInit(@NonNull Context context,
		@NonNull Configuration configuration,
		@NonNull TaskExecutor workTaskExecutor,
		@NonNull WorkDatabase workDatabase,
		@NonNull List<Scheduler> schedulers,
		@NonNull Processor processor) {

	context = context.getApplicationContext();
	mContext = context;
	mConfiguration = configuration;
	mWorkTaskExecutor = workTaskExecutor;
	mWorkDatabase = workDatabase;
	mSchedulers = schedulers;
	mProcessor = processor;
	mPreferenceUtils = new PreferenceUtils(workDatabase);
	mForceStopRunnableCompleted = false;

	// Check for direct boot mode
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && context.isDeviceProtectedStorage()) {
		throw new IllegalStateException("Cannot initialize WorkManager in direct boot mode");
	}

	// Checks for app force stops.
	mWorkTaskExecutor.executeOnBackgroundThread(new ForceStopRunnable(context, this));
}
```

è®°å½•äº† `Configuration`ï¼Œ`TaskExecutor`ï¼Œ`WorkDatabase`ï¼Œ`schedulers`ï¼Œ`Processor` ç­‰ã€‚

ç„¶åæˆ‘ä»¬çœ‹æœ€åä¸€è¡Œæ‰§è¡Œè¯­å¥ï¼Œå¯åŠ¨äº†ä¸€ä¸ª `ForceStopRunnable`ï¼Œè¿™ä¸ª Runnable æ˜¯å¹²ä»€ä¹ˆç”¨çš„å‘¢ï¼Ÿç›´æ¥çœ‹ run() çš„å®ç°ï¼š

```java
@Override
public void run() {
	try {
		if (!multiProcessChecks()) {
			return;
		}
		while (true) {
			// Migrate the database to the no-backup directory if necessary.
			WorkDatabasePathHelper.migrateDatabase(mContext);
			// Clean invalid jobs attributed to WorkManager, and Workers that might have been
			// interrupted because the application crashed (RUNNING state).
			Logger.get().debug(TAG, "Performing cleanup operations.");
			try {
				forceStopRunnable();
				break;
			} catch (SQLiteCantOpenDatabaseException
					| SQLiteDatabaseCorruptException
					| SQLiteDatabaseLockedException
					| SQLiteTableLockedException
					| SQLiteConstraintException
					| SQLiteAccessPermException exception) {
				mRetryCount++;
				if (mRetryCount >= MAX_ATTEMPTS) {
					// ForceStopRunnable is usually the first thing that accesses a database
					// (or an app's internal data directory). This means that weird
					// PackageManager bugs are attributed to ForceStopRunnable, which is
					// unfortunate. This gives the developer a better error
					// message.
					String message = "The file system on the device is in a bad state. "
							+ "WorkManager cannot access the app's internal data store.";
					Logger.get().error(TAG, message, exception);
					IllegalStateException throwable = new IllegalStateException(message,
							exception);
					InitializationExceptionHandler exceptionHandler =
							mWorkManager.getConfiguration().getExceptionHandler();
					if (exceptionHandler != null) {
						Logger.get().debug(TAG,
								"Routing exception to the specified exception handler",
								throwable);
						exceptionHandler.handleException(throwable);
						break;
					} else {
						throw throwable;
					}
				} else {
					long duration = mRetryCount * BACKOFF_DURATION_MS;
					Logger.get()
							.debug(TAG, String.format("Retrying after %s", duration),
									exception);
					sleep(mRetryCount * BACKOFF_DURATION_MS);
				}
			}
		}
	} finally {
		mWorkManager.onForceStopRunnableCompleted();
	}
}
```

- å‡çº§æ•°æ®åº“

è¿™ä¸ª Runnable çš„ä½œç”¨å°±æ˜¯åœ¨ WorkManager åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œå‘ç°äº†æœªå®Œæˆçš„ï¼Œéœ€è¦é‡æ–°æ‰§è¡Œçš„ä»»åŠ¡ï¼Œæˆ–è€… app è¢«å¼ºåˆ¶ kill çš„æƒ…å†µä¸‹ï¼Œç›´æ¥å¯¹ Scheduler è¿›è¡Œè°ƒåº¦ã€‚åˆ°æ­¤ï¼Œä¸€ä¸ª WorkManager çš„åˆå§‹åŒ–æµç¨‹å°±å®Œæˆäº†ã€‚

#### åˆå§‹åŒ–å°ç»“

1. `WorkManager` çš„åˆå§‹åŒ–æ˜¯åœ¨ app å†·å¯åŠ¨åï¼Œç”± `WorkManagerInitializer` è¿™ä¸ª `ContentProvider` æ‰§è¡Œçš„ã€‚
2. åˆå§‹åŒ–è¿‡ç¨‹åŒ…å«äº† `Configuration`ï¼Œ`WorkManagerTaskExecutor`ï¼Œ`WorkDatabase`ï¼Œ`Schedulers`ï¼Œ`Processor` ç­‰çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚
3. Schedulers æœ‰ä¸¤ä¸ªã€‚
   - (1) `GreedyScheduler`: æ‰§è¡Œæ²¡æœ‰ä»»ä½•çº¦æŸçš„éå‘¨æœŸæ€§çš„ä»»åŠ¡ã€‚
   - (2) `SystemJobScheduler` / `GcmBasedScheduler` / `SystemAlarmScheduler`: æ‰§è¡Œå‘¨æœŸæ€§æˆ–è€…æœ‰çº¦æŸæ€§çš„ä»»åŠ¡ã€‚ä¼˜å…ˆè¿”å› SystemJobSchedulerï¼Œåœ¨ build version å°äº 23 çš„æƒ…å†µä¸‹å…ˆå°è¯•è¿”å› GcmBasedSchedulerï¼Œè‹¥è¿”å›ä¸ºç©ºå†è¿”å› SystemAlarmSchedulerã€‚
4. åˆå§‹åŒ–çš„æœ€åï¼Œä¼šæ ¹æ®æƒ…å†µæ‰¾åˆ°éœ€è¦è¢«æ‰§è¡Œçš„ä»»åŠ¡è¿›è¡Œè°ƒåº¦æ‰§è¡Œã€‚
5. WorkManager åˆå§‹åŒ–æµç¨‹å›¾

![](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202408160012416.png)

### WorkRequest çš„åˆ›å»º

ä»¥ `OneTimeWorkRequest` ä¸ºä¾‹ï¼š`val work1Request = OneTimeWorkRequestBuilder<Worker1>().build()`

```java
// OneTimeWorkRequest.Builder
public Builder(@NonNull Class<? extends ListenableWorker> workerClass) {
	super(workerClass);
	mWorkSpec.inputMergerClassName = OverwritingInputMerger.class.getName();
}
// WorkRequest.Builder
UUID mId;  
WorkSpec mWorkSpec;  
Set<String> mTags = new HashSet<>();
Builder(@NonNull Class<? extends ListenableWorker> workerClass) {  
    mId = UUID.randomUUID();  
    mWorkerClass = workerClass;  
    mWorkSpec = new WorkSpec(mId.toString(), workerClass.getName());  
    addTag(workerClass.getName());  
}
```

- `OneTimeWorkRequest` ä¸º `builder` å¯¹è±¡åˆ›å»ºäº† `WorkSpec` å¯¹è±¡ç”¨æ¥ä¿å­˜ä»»åŠ¡ id å’Œç±»å
- å…¶ä¸­ `id` æ˜¯é€šè¿‡ `UUID` è‡ªåŠ¨ç”Ÿæˆçš„ã€‚
- `request` çš„ `tag` é»˜è®¤æ˜¯é€šè¿‡ç±»åç”Ÿæˆçš„ï¼Œå¤–éƒ¨ä¹Ÿå¯è°ƒç”¨ `addTag()` æ–¹æ³•è®¾ç½®æ ‡ç­¾ã€‚å¦å¤–ä¸º `WorkSpec` è®¾ç½®äº†é»˜è®¤çš„ä»»åŠ¡è¾“å…¥æµçš„åˆå¹¶è§„åˆ™: `OverwritingInputMerger`ã€‚

æ¥ç€çœ‹ `build()` æ–¹æ³•ï¼š

```java
public final @NonNull W build() {
	W returnValue = buildInternal();
	Constraints constraints = mWorkSpec.constraints;
	// Check for unsupported constraints.
	boolean hasUnsupportedConstraints =
			(Build.VERSION.SDK_INT >= 24 && constraints.hasContentUriTriggers())
					|| constraints.requiresBatteryNotLow()
					|| constraints.requiresCharging()
					|| (Build.VERSION.SDK_INT >= 23 && constraints.requiresDeviceIdle());
	if (mWorkSpec.expedited) {
		if (hasUnsupportedConstraints) {
			throw new IllegalArgumentException(
					"Expedited jobs only support network and storage constraints");
		}
		if (mWorkSpec.initialDelay > 0) {
			throw new IllegalArgumentException("Expedited jobs cannot be delayed");
		}
	}
	// Create a new id and WorkSpec so this WorkRequest.Builder can be used multiple times.
	mId = UUID.randomUUID();
	mWorkSpec = new WorkSpec(mWorkSpec);
	mWorkSpec.id = mId.toString();
	return returnValue;
}
abstract @NonNull W buildInternal();
```

åœ¨ buildInternal() æ‹¿åˆ° OneTimeWorkRequest å¯¹è±¡ä¹‹åï¼Œä¸º Builder åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ WorkSpec å¯¹è±¡ï¼Œå¹¶èµ‹äºˆäº†æ–°çš„ UUIDã€‚è™½ç„¶ä¸åŸå…ˆçš„ WorkSpec å¯¹è±¡ä¸­æ¯ä¸ªå±æ€§çš„å€¼æ˜¯ä¸€è‡´çš„ï¼Œä½†æŒ‡å‘äº†ä¸åŒçš„å†…å­˜åœ°å€ã€‚è¿™ä¹ˆåšçš„ç›®çš„æ˜¯ä¸ºäº†è¿™ä¸ª Builder å¯¹è±¡å¯è¢«é‡å¤åˆ©ç”¨ã€‚å¥½äº†ï¼Œç°åœ¨æˆ‘ä»¬ä¸€ä¸ªä»»åŠ¡çš„ WorkRequest åˆ›å»ºå°±å®Œæˆäº†ã€‚

`buildInternal()` æ–¹æ³•è¿”å›äº†ä¸€ä¸ª `WorkRequest` å¯¹è±¡ï¼Œè¿™æ˜¯ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œåœ¨å­ç±» `OneTimeWorkRequest.Builder` ä¸­çš„å®ç°å¦‚ä¸‹ï¼š

```java
// OneTimeWorkRequest
@Override
@NonNull OneTimeWorkRequest buildInternal() {
	if (mBackoffCriteriaSet && Build.VERSION.SDK_INT >= 23 
		&& mWorkSpec.constraints.requiresDeviceIdle()) {
		throw new IllegalArgumentException("Cannot set backoff criteria on an idle mode job");
	}
	return new OneTimeWorkRequest(this);
}
OneTimeWorkRequest(Builder builder) {  
    super(builder.mId, builder.mWorkSpec, builder.mTags);  
}
```

#### å°ç»“

**æ€»ç»“:**

WorkRequest çš„åˆ›å»ºæ˜¯ä¸ºäº†æŒæœ‰ä¸‰ä¸ªé‡è¦çš„æˆå‘˜å˜é‡ã€‚åˆ†åˆ«æ˜¯:

1. mId: ç”± UUID ç”Ÿæˆçš„ä»»åŠ¡ idã€‚
2. mWorkSpec: æ¯ä¸ªä»»åŠ¡çš„å±æ€§ã€‚
3. mTags: æ¯ä¸ªä»»åŠ¡çš„æ ‡ç­¾ã€‚

æµç¨‹å›¾ï¼š

![](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202408160050733.png)

## éçº¦æŸæ¡ä»¶ä»»åŠ¡çš„æ‰§è¡Œè¿‡ç¨‹

### OneTime ä¸€æ¬¡æ€§ä»»åŠ¡

ä»¥ `OneTimeWorkRequest` ä¸ºä¾‹ï¼š

```kotlin
WorkManager.getInstance(this).enqueue(work1Request)
```

`WorkManager.getInstance()` è·å–åˆ°çš„æ˜¯ `WorkManagerImpl`

```java
// WorkManagerImpl.java
@Override
@NonNull
public Operation enqueue(@NonNull List<? extends WorkRequest> requests) {
	// ...
	return new WorkContinuationImpl(this, requests).enqueue();
}
```

åˆ›å»ºä¸€ä¸ª `WorkContinuationImpl()` å¯¹è±¡ï¼Œå†æ‰§è¡Œ `enqueue()` æ–¹æ³•ã€‚`WorkContinuationImpl` æ˜¯ `WorkContinuation` çš„å­ç±»ã€‚ç”¨æ¥æŠŠå¤šä¸ª `OneTimeWorkRequest` æ ¹æ®éœ€æ±‚ä¸²è¡Œï¼Œå¹¶è¡Œæˆ–åˆå¹¶å¤„ç†ã€‚æˆ‘ä»¬ç†Ÿæ‚‰çš„ `then()`ï¼Œ`combine()`ï¼Œ`enqueue()` ç­‰éƒ½æ˜¯è¿™ä¸ªç±»çš„æ–¹æ³•ã€‚

```java
// WorkContinuationImpl.java
public WorkContinuationImpl(@NonNull WorkManagerImpl workManagerImpl,
		@Nullable String name,
		@NonNull ExistingWorkPolicy existingWorkPolicy,
		@NonNull List<? extends WorkRequest> work,
		@Nullable List<WorkContinuationImpl> parents) {
	mWorkManagerImpl = workManagerImpl;
	mName = name;
	mExistingWorkPolicy = existingWorkPolicy;
	mWork = work;
	mParents = parents;
	mIds = new ArrayList<>(mWork.size());
	mAllIds = new ArrayList<>();
	if (parents != null) {
		for (WorkContinuationImpl parent : parents) {
			mAllIds.addAll(parent.mAllIds);
		}
	}
	for (int i = 0; i < work.size(); i++) {
		String id = work.get(i).getStringId();
		mIds.add(id);
		mAllIds.add(id);
	}
}
```

`WorkContinuation` ä¿å­˜äº†ä»»åŠ¡ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯ï¼Œå¦‚ `WorkManager`ï¼Œ`WorkRequest`ï¼Œçˆ¶ `WorkContinuation` ç­‰ã€‚

ç»§ç»­çœ‹ `WorkContinuationImpl` çš„ `enqueue()` æ–¹æ³•çš„å®ç°:

```java
// WorkContinuationImpl.java
@Override
public @NonNull Operation enqueue() {
	// Only enqueue if not already enqueued.
	if (!mEnqueued) {
		// The runnable walks the hierarchy of the continuations
		// and marks them enqueued using the markEnqueued() method, parent first.
		EnqueueRunnable runnable = new EnqueueRunnable(this);
		mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(runnable);
		mOperation = runnable.getOperation();
	} else {
		Logger.get().warning(TAG,
				String.format("Already enqueued work ids (%s)", TextUtils.join(", ", mIds)));
	}
	return mOperation;
}
```

`WorkManager` çš„ `TaskExecutor` æ‰§è¡Œäº† `EnqueueRunnable`ã€‚`EnqueueRunnable` ä¸­ `run()` çš„å®ç°:

```java
// EnqueueRunnable.java
@Override
public void run() {
	try {
		// ...
		boolean needsScheduling = addToDatabase();
		if (needsScheduling) {
			// Enable RescheduleReceiver, only when there are Worker's that need scheduling.
			final Context context =
					mWorkContinuation.getWorkManagerImpl().getApplicationContext();
			PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, true);
			scheduleWorkInBackground();
		}
		mOperation.setState(Operation.SUCCESS);
	} catch (Throwable exception) {
		mOperation.setState(new Operation.State.FAILURE(exception));
	}
}
```

- `addToDatabase()` çš„ä½œç”¨æ˜¯æŠŠ `WorkSpec` å­˜å…¥åˆ°æ•°æ®åº“ï¼Œå¹¶å¯¹ä»»åŠ¡çš„çŠ¶æ€è¿›è¡Œæ ¡éªŒã€‚æˆåŠŸè¿”å› trueã€‚
- `PackageManagerHelper.setComponentEnabled()` å¼€å¯äº† `RescheduleReceiver`ã€‚é€šè¿‡åç¼–è¯‘æˆ‘ä»¬å¾—çŸ¥è¿™ä¸ª `Receiver` æ˜¯åœ¨ `AndroidManifest` ä¸­æ³¨å†Œçš„ï¼Œé»˜è®¤æ˜¯ disable çš„ã€‚ç›‘å¬äº†å¼€æœº (`BOOT_COMPLETED`)ï¼Œæ—¶é—´å˜åŒ– (`TIME_SET`)ï¼Œæ—¶åŒºå˜åŒ– (`TIMEZONE_CHANGED`) è¿™ä¸‰ä¸ªå¹¿æ’­ã€‚

```xml
<receiver
	android:name="androidx.work.impl.background.systemalarm.RescheduleReceiver"
	android:directBootAware="false"
	android:enabled="false"
	android:exported="false"
	android:process=":worker1"
	tools:targetApi="n">
	<intent-filter>
		<action android:name="android.intent.action.BOOT_COMPLETED" />
		<action android:name="android.intent.action.TIME_SET" />
		<action android:name="android.intent.action.TIMEZONE_CHANGED" />
	</intent-filter>
</receiver>
```

- `scheduleWorkInBackground()` å®ç°

```java
@VisibleForTesting
public void scheduleWorkInBackground() {
	WorkManagerImpl workManager = mWorkContinuation.getWorkManagerImpl();
	Schedulers.schedule(
			workManager.getConfiguration(),
			workManager.getWorkDatabase(),
			workManager.getSchedulers());
}
```

è¿™éƒ¨åˆ†å°±æ˜¯ä»»åŠ¡è°ƒåº¦çš„å®ç°ã€‚æ‹¿åˆ° `WorkManager` å¯¹è±¡åè°ƒç”¨äº† `Schedulers.schedule()` æ–¹æ³•ï¼Œä¼ å…¥äº† `Configuration`, `WorkDatabase`, `Scheduler` è¿™ä¸‰ä¸ªå¯¹è±¡ã€‚æ‰§è¡Œ `schedule()` æ–¹æ³•:

```java
// Schedulers.java
public class Schedulers {

    public static final String GCM_SCHEDULER = "androidx.work.impl.background.gcm.GcmScheduler";
    private static final String TAG = Logger.tagWithPrefix("Schedulers");

    /**
     * Schedules {@link WorkSpec}s while honoring the {@link Scheduler#MAX_SCHEDULER_LIMIT}.
     *
     * @param workDatabase The {@link WorkDatabase}.
     * @param schedulers   The {@link List} of {@link Scheduler}s to delegate to.
     */
    public static void schedule(
            @NonNull Configuration configuration,
            @NonNull WorkDatabase workDatabase,
            List<Scheduler> schedulers) {
        if (schedulers == null || schedulers.size() == 0) {
            return;
        }

        WorkSpecDao workSpecDao = workDatabase.workSpecDao();
        List<WorkSpec> eligibleWorkSpecsForLimitedSlots;
        List<WorkSpec> allEligibleWorkSpecs;

        workDatabase.beginTransaction();
        try {
            // Enqueued workSpecs when scheduling limits are applicable.
            eligibleWorkSpecsForLimitedSlots = workSpecDao.getEligibleWorkForScheduling(
                    configuration.getMaxSchedulerLimit());

            // Enqueued workSpecs when scheduling limits are NOT applicable.
            allEligibleWorkSpecs = workSpecDao.getAllEligibleWorkSpecsForScheduling(
                    MAX_GREEDY_SCHEDULER_LIMIT);

            if (eligibleWorkSpecsForLimitedSlots != null
                    && eligibleWorkSpecsForLimitedSlots.size() > 0) {
                long now = System.currentTimeMillis();

                // Mark all the WorkSpecs as scheduled.
                // Calls to Scheduler#schedule() could potentially result in more schedules
                // on a separate thread. Therefore, this needs to be done first.
                for (WorkSpec workSpec : eligibleWorkSpecsForLimitedSlots) {
                    workSpecDao.markWorkSpecScheduled(workSpec.id, now);
                }
            }
            workDatabase.setTransactionSuccessful();
        } finally {
            workDatabase.endTransaction();
        }

        if (eligibleWorkSpecsForLimitedSlots != null
                && eligibleWorkSpecsForLimitedSlots.size() > 0) {

            WorkSpec[] eligibleWorkSpecsArray =
                    new WorkSpec[eligibleWorkSpecsForLimitedSlots.size()];
            eligibleWorkSpecsArray =
                    eligibleWorkSpecsForLimitedSlots.toArray(eligibleWorkSpecsArray);

            // Delegate to the underlying schedulers.
            for (Scheduler scheduler : schedulers) {
                if (scheduler.hasLimitedSchedulingSlots()) {
                    scheduler.schedule(eligibleWorkSpecsArray);
                }
            }
        }

        if (allEligibleWorkSpecs != null && allEligibleWorkSpecs.size() > 0) {
            WorkSpec[] enqueuedWorkSpecsArray = new WorkSpec[allEligibleWorkSpecs.size()];
            enqueuedWorkSpecsArray = allEligibleWorkSpecs.toArray(enqueuedWorkSpecsArray);
            // Delegate to the underlying schedulers.
            for (Scheduler scheduler : schedulers) {
                if (!scheduler.hasLimitedSchedulingSlots()) {
                    scheduler.schedule(enqueuedWorkSpecsArray);
                }
            }
        }
    }
    // ...
}
```

- å…ˆè¿›è¡Œäº†ä¸€ç³»åˆ—çš„æ•°æ®åº“æ“ä½œï¼Œç„¶åå¼€å§‹æ ¹æ®æ¡ä»¶æ¯ä¸ªä»»åŠ¡è¿›è¡Œè°ƒåº¦ã€‚å…¶ä¸­ `eligibleWorkSpecs` è¿”å›çš„æ˜¯åœ¨ `ENQUEUED` çŠ¶æ€ä¸‹ï¼Œæœªè¢«æ‰§è¡Œä¸”æœªè¢«å–æ¶ˆçš„ `WorkSpec` åˆ—è¡¨ï¼Œç„¶åæ›´æ–°è¿™äº›ä»»åŠ¡çš„ `request` çŠ¶æ€åˆ°æ•°æ®åº“ã€‚
- æœ€åéå† `schedulers` è°ƒç”¨ `scheduler.schedule()` å¯¹æ¯ä¸ªä»»åŠ¡è¿›è¡Œè°ƒåº¦å¤„ç†ã€‚ç”±äºç¤ºä¾‹ä»£ç åˆ›å»ºçš„æ˜¯æ²¡æœ‰çº¦æŸçš„ä¸€æ¬¡æ€§ä»»åŠ¡ï¼Œæ‰€ä»¥çœ‹ä¸€ä¸‹ `GreedyScheduler` å¯¹äº `schedule()` æ–¹æ³•çš„å®ç°:

```java
// GreedyScheduler.java
@Override
public void schedule(@NonNull WorkSpec... workSpecs) {
	if (mInDefaultProcess == null) {
		checkDefaultProcess();
	}

	if (!mInDefaultProcess) {
		Logger.get().info(TAG, "Ignoring schedule request in a secondary process");
		return;
	}

	registerExecutionListenerIfNeeded();

	// Keep track of the list of new WorkSpecs whose constraints need to be tracked.
	// Add them to the known list of constrained WorkSpecs and call replace() on
	// WorkConstraintsTracker. That way we only need to synchronize on the part where we
	// are updating mConstrainedWorkSpecs.
	Set<WorkSpec> constrainedWorkSpecs = new HashSet<>();
	Set<String> constrainedWorkSpecIds = new HashSet<>();

	for (WorkSpec workSpec : workSpecs) {
		long nextRunTime = workSpec.calculateNextRunTime();
		long now = System.currentTimeMillis();
		if (workSpec.state == WorkInfo.State.ENQUEUED) {
			if (now < nextRunTime) {
				// Future work
				if (mDelayedWorkTracker != null) {
					mDelayedWorkTracker.schedule(workSpec);
				}
			} else if (workSpec.hasConstraints()) {
				if (SDK_INT >= 23 && workSpec.constraints.requiresDeviceIdle()) {
					// Ignore requests that have an idle mode constraint.
					Logger.get().debug(TAG,
							String.format("Ignoring WorkSpec %s, Requires device idle.",
									workSpec));
				} else if (SDK_INT >= 24 && workSpec.constraints.hasContentUriTriggers()) {
					// Ignore requests that have content uri triggers.
					Logger.get().debug(TAG,
							String.format("Ignoring WorkSpec %s, Requires ContentUri triggers.",
									workSpec));
				} else {
					constrainedWorkSpecs.add(workSpec);
					constrainedWorkSpecIds.add(workSpec.id);
				}
			} else {
				Logger.get().debug(TAG, String.format("Starting work for %s", workSpec.id));
				mWorkManagerImpl.startWork(workSpec.id);
			}
		}
	}

	// onExecuted() which is called on the main thread also modifies the list of mConstrained
	// WorkSpecs. Therefore we need to lock here.
	synchronized (mLock) {
		if (!constrainedWorkSpecs.isEmpty()) {
			Logger.get().debug(TAG, String.format("Starting tracking for [%s]",
					TextUtils.join(",", constrainedWorkSpecIds)));
			mConstrainedWorkSpecs.addAll(constrainedWorkSpecs);
			mWorkConstraintsTracker.replace(mConstrainedWorkSpecs);
		}
	}
}
```

`WorkSpec` æ˜¯ `ENQUEUED` çš„çŠ¶æ€ï¼›éå‘¨æœŸæ€§ä»»åŠ¡ï¼›éå»¶è¿Ÿä»»åŠ¡ï¼›éæ’¤é”€çš„ä»»åŠ¡ï¼›æ²¡æœ‰å…¶å®ƒçº¦æŸçš„ä»»åŠ¡ æ»¡è¶³è¿™äº”ä¸ªæ¡ä»¶åï¼Œç›´æ¥è°ƒç”¨:

```java
// GreedyScheduler
mWorkManagerImpl.startWork(workSpec.id);

// WorkManagerImpl.java
public void startWork(String workSpecId, WorkerParameters.RuntimeExtras runtimeExtras) {  
    mWorkTaskExecutor  
		.executeOnBackgroundThread(  
			new StartWorkRunnable(this, workSpecId, runtimeExtras));  
}
```

`WorkTaskExecutor` å¯¹ä»»åŠ¡è¿›è¡Œäº†è°ƒåº¦ã€‚`StartWorkRunnable` çš„ `run()` çš„å®ç°ï¼š

```java
// StartWorkRunnable.java
@Override
public void run() {
	mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras);
}
```

`StartWorkRunnable` ä¼šå°†ä»»åŠ¡çš„ä¿¡æ¯äº¤ç»™ `Processor`ï¼Œç”± `Processor` è°ƒç”¨ `startWork()` å»æ‰§è¡Œä»»åŠ¡:

```java
// Processor.java
public boolean startWork(
		@NonNull String id,
		@Nullable WorkerParameters.RuntimeExtras runtimeExtras) {

	WorkerWrapper workWrapper;
	synchronized (mLock) {
		// Work may get triggered multiple times if they have passing constraints
		// and new work with those constraints are added.
		if (isEnqueued(id)) {
			Logger.get().debug(
					TAG,
					String.format("Work %s is already enqueued for processing", id));
			return false;
		}

		workWrapper =
				new WorkerWrapper.Builder(
						mAppContext,
						mConfiguration,
						mWorkTaskExecutor,
						this,
						mWorkDatabase,
						id)
						.withSchedulers(mSchedulers)
						.withRuntimeExtras(runtimeExtras)
						.build();
		ListenableFuture<Boolean> future = workWrapper.getFuture();
		future.addListener(
				new FutureListener(this, id, future),
				mWorkTaskExecutor.getMainThreadExecutor());
		mEnqueuedWorkMap.put(id, workWrapper);
	}
	mWorkTaskExecutor.getBackgroundExecutor().execute(workWrapper);
	Logger.get().debug(TAG, String.format("%s: processing %s", getClass().getSimpleName(), id));
	return true;
}
```

`startWork()` æ–¹æ³•ä¸­åˆ›å»ºäº†ä¸€ä¸ª `WorkerWrapper` çš„ `Runnable` å¯¹è±¡ï¼Œäº¤ç”± `WorkTaskExecutor` è°ƒåº¦å¤„ç†ã€‚`WorkerWrapper` çš„ `run()` æ–¹æ³•çš„å®ç°:

```java
// WorkerWrapper.java
public void run() {
	mTags = mWorkTagDao.getTagsForWorkSpecId(mWorkSpecId);
	mWorkDescription = createWorkDescription(mTags);
	runWorker();
}
private void runWorker() {  
    if (tryCheckForInterruptionAndResolve()) {  
        return;  
    }  
  
    mWorkDatabase.beginTransaction();  
    try {  
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);  
        if (mWorkSpec == null) {  
            Logger.get().error(  
                    TAG,  
                    String.format("Didn't find WorkSpec for id %s", mWorkSpecId));  
            resolve(false);  
            mWorkDatabase.setTransactionSuccessful();  
            return;        }  
  
        // Do a quick check to make sure we don't need to bail out in case this work is already  
        // running, finished, or is blocked.        if (mWorkSpec.state != ENQUEUED) {  
            resolveIncorrectStatus();  
            mWorkDatabase.setTransactionSuccessful();  
            Logger.get().debug(TAG,  
                    String.format("%s is not in ENQUEUED state. Nothing more to do.",  
                            mWorkSpec.workerClassName));  
            return;        }  
  
        // Case 1:  
        // Ensure that Workers that are backed off are only executed when they are supposed to.        // GreedyScheduler can schedule WorkSpecs that have already been backed off because        // it is holding on to snapshots of WorkSpecs. So WorkerWrapper needs to determine        // if the ListenableWorker is actually eligible to execute at this point in time.  
        // Case 2:        // On API 23, we double scheduler Workers because JobScheduler prefers batching.        // So is the Work is periodic, we only need to execute it once per interval.        // Also potential bugs in the platform may cause a Job to run more than once.  
        if (mWorkSpec.isPeriodic() || mWorkSpec.isBackedOff()) {  
            long now = System.currentTimeMillis();  
            // Allow first run of a PeriodicWorkRequest  
            // to go through. This is because when periodStartTime=0;            // calculateNextRunTime() always > now.            // For more information refer to b/124274584            boolean isFirstRun = mWorkSpec.periodStartTime == 0;  
            if (!isFirstRun && now < mWorkSpec.calculateNextRunTime()) {  
                Logger.get().debug(TAG,  
                        String.format(  
                                "Delaying execution for %s because it is being executed "  
                                        + "before schedule.",  
                                mWorkSpec.workerClassName));  
                // For AlarmManager implementation we need to reschedule this kind  of Work.  
                // This is not a problem for JobScheduler because we will only reschedule                // work if JobScheduler is unaware of a jobId.                resolve(true);  
                mWorkDatabase.setTransactionSuccessful();  
                return;            }  
        }  
  
        // Needed for nested transactions, such as when we're in a dependent work request when  
        // using a SynchronousExecutor.        mWorkDatabase.setTransactionSuccessful();  
    } finally {  
        mWorkDatabase.endTransaction();  
    }  
  
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside  
    // a database transaction.    Data input;  
    if (mWorkSpec.isPeriodic()) {  
        input = mWorkSpec.input;  
    } else {  
        InputMergerFactory inputMergerFactory = mConfiguration.getInputMergerFactory();  
        String inputMergerClassName = mWorkSpec.inputMergerClassName;  
        InputMerger inputMerger =  
                inputMergerFactory.createInputMergerWithDefaultFallback(inputMergerClassName);  
        if (inputMerger == null) {  
            Logger.get().error(TAG, String.format("Could not create Input Merger %s",  
                    mWorkSpec.inputMergerClassName));  
            setFailedAndResolve();  
            return;        }  
        List<Data> inputs = new ArrayList<>();  
        inputs.add(mWorkSpec.input);  
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));  
        input = inputMerger.merge(inputs);  
    }  
  
    final WorkerParameters params = new WorkerParameters(  
            UUID.fromString(mWorkSpecId),  
            input,  
            mTags,  
            mRuntimeExtras,  
            mWorkSpec.runAttemptCount,  
            mConfiguration.getExecutor(),  
            mWorkTaskExecutor,  
            mConfiguration.getWorkerFactory(),  
            new WorkProgressUpdater(mWorkDatabase, mWorkTaskExecutor),  
            new WorkForegroundUpdater(mWorkDatabase, mForegroundProcessor, mWorkTaskExecutor));  
  
    // Not always creating a worker here, as the WorkerWrapper.Builder can set a worker override  
    // in test mode.    if (mWorker == null) {  
        mWorker = mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(  
                mAppContext,  
                mWorkSpec.workerClassName,  
                params);  
    }  
  
    if (mWorker == null) {  
        Logger.get().error(TAG,  
                String.format("Could not create Worker %s", mWorkSpec.workerClassName));  
        setFailedAndResolve();  
        return;    }  
  
    if (mWorker.isUsed()) {  
        Logger.get().error(TAG,  
                String.format("Received an already-used Worker %s; WorkerFactory should return "  
                        + "new instances",  
                        mWorkSpec.workerClassName));  
        setFailedAndResolve();  
        return;    }  
    mWorker.setUsed();  
  
    // Try to set the work to the running state.  Note that this may fail because another thread  
    // may have modified the DB since we checked last at the top of this function.    if (trySetRunning()) {  
        if (tryCheckForInterruptionAndResolve()) {  
            return;  
        }  
  
        final SettableFuture<ListenableWorker.Result> future = SettableFuture.create();  
        final WorkForegroundRunnable foregroundRunnable =  
                new WorkForegroundRunnable(  
                        mAppContext,  
                        mWorkSpec,  
                        mWorker,  
                        params.getForegroundUpdater(),  
                        mWorkTaskExecutor  
                );  
        mWorkTaskExecutor.getMainThreadExecutor().execute(foregroundRunnable);  
  
        final ListenableFuture<Void> runExpedited = foregroundRunnable.getFuture();  
        runExpedited.addListener(new Runnable() {  
            @Override  
            public void run() {  
                try {  
                    runExpedited.get();  
                    Logger.get().debug(TAG,  
                            String.format("Starting work for %s", mWorkSpec.workerClassName));  
                    // Call mWorker.startWork() on the main thread.  
                    mInnerFuture = mWorker.startWork();  
                    future.setFuture(mInnerFuture);  
                } catch (Throwable e) {  
                    future.setException(e);  
                }  
            }  
        }, mWorkTaskExecutor.getMainThreadExecutor());  
  
        // Avoid synthetic accessors.  
        final String workDescription = mWorkDescription;  
        future.addListener(new Runnable() {  
            @Override  
            @SuppressLint("SyntheticAccessor")  
            public void run() {  
                try {  
                    // If the ListenableWorker returns a null result treat it as a failure.  
                    ListenableWorker.Result result = future.get();  
                    if (result == null) {  
                        Logger.get().error(TAG, String.format(  
                                "%s returned a null result. Treating it as a failure.",  
                                mWorkSpec.workerClassName));  
                    } else {  
                        Logger.get().debug(TAG, String.format("%s returned a %s result.",  
                                mWorkSpec.workerClassName, result));  
                        mResult = result;  
                    }  
                } catch (CancellationException exception) {  
                    // Cancellations need to be treated with care here because innerFuture  
                    // cancellations will bubble up, and we need to gracefully handle that.                    Logger.get().info(TAG, String.format("%s was cancelled", workDescription),  
                            exception);  
                } catch (InterruptedException | ExecutionException exception) {  
                    Logger.get().error(TAG,  
                            String.format("%s failed because it threw an exception/error",  
                                    workDescription), exception);  
                } finally {  
                    onWorkFinished();  
                }  
            }  
        }, mWorkTaskExecutor.getBackgroundExecutor());  
    } else {  
        resolveIncorrectStatus();  
    }  
}
```

- å…ˆåˆ›å»ºä¸€ä¸ª `WorkerParameters` å¯¹è±¡ã€‚
- ç„¶åè°ƒç”¨ `mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback()` æ–¹æ³•åˆ›å»º `Worker` å¯¹è±¡ï¼Œè¿”å›çš„å°±æ˜¯æˆ‘ä»¬è‡ªå·±çš„ `Woker` å¯¹è±¡ï¼Œå³ `Worker1` çš„å®ä¾‹ã€‚ä¹‹åäº¤ç”± `WorkTaskExecutor` è°ƒåº¦å¤„ç†ã€‚åœ¨ `run()` æ–¹æ³•çš„å®ç°ï¼Œæˆ‘ä»¬çœ‹åˆ°è°ƒç”¨äº† `mWorker.startWork()` æ–¹æ³•:
- `ListenableWorker` æ˜¯ä¸ªæŠ½è±¡ç±»ï¼Œæ˜¯æ‰€æœ‰ `Worker` çš„çˆ¶ç±»ã€‚`Worker1` ä¹Ÿç»§æ‰¿ `Worker` ç±»ï¼Œ`startWork()` åœ¨ `Worker` ä¸­çš„å®ç°:

```java
// Worker
@Override
public final @NonNull ListenableFuture<Result> startWork() {
	mFuture = SettableFuture.create();
	getBackgroundExecutor().execute(new Runnable() {
		@Override
		public void run() {
			try {
				Result result = doWork();
				mFuture.set(result);
			} catch (Throwable throwable) {
				mFuture.setException(throwable);
			}

		}
	});
	return mFuture;
}
```

åœ¨ `run()` çš„å®ç°æ‰§è¡Œäº† `doWork()` æ–¹æ³•ï¼Œå³æ‰§è¡Œäº†æˆ‘ä»¬ `Worker1` çš„ `doWork()` æ–¹æ³•ã€‚

```java
// Worker1
class Worker1(appContext: Context, workerParams: WorkerParameters) :
    Worker(appContext, workerParams) {

    override fun doWork(): Result {
        Thread.sleep(5000)
        return Result.success()
    }
}
```

startWork()Â è¿”å›äº†ä¸€ä¸ª Future å¯¹è±¡ mInnerFutureï¼Œè°ƒç”¨ future.setFuture(mInnerFuture) å»å¤„ç† doWork() è¿”å›çš„ resultã€‚å†ç»è¿‡ä¸€ç³»åˆ—åˆ¤æ–­åï¼Œæœ€ç»ˆæ‰§è¡Œäº† `onWorkFinished()` æ–¹æ³•:

```java
// WorkerWrapper.java
void onWorkFinished() {
	if (!tryCheckForInterruptionAndResolve()) {
		mWorkDatabase.beginTransaction();
		try {
			WorkInfo.State state = mWorkSpecDao.getState(mWorkSpecId);
			mWorkDatabase.workProgressDao().delete(mWorkSpecId);
			if (state == null) {
				// state can be null here with a REPLACE on beginUniqueWork().
				// Treat it as a failure, and rescheduleAndResolve() will
				// turn into a no-op. We still need to notify potential observers
				// holding on to wake locks on our behalf.
				resolve(false);
			} else if (state == RUNNING) {
				handleResult(mResult);
			} else if (!state.isFinished()) {
				rescheduleAndResolve();
			}
			mWorkDatabase.setTransactionSuccessful();
		} finally {
			mWorkDatabase.endTransaction();
		}
	}

	// Try to schedule any newly-unblocked workers, and workers requiring rescheduling (such as
	// periodic work using AlarmManager).  This code runs after runWorker() because it should
	// happen in its own transaction.

	// Cancel this work in other schedulers.  For example, if this work was
	// handled by GreedyScheduler, we should make sure JobScheduler is informed
	// that it should remove this job and AlarmManager should remove all related alarms.
	if (mSchedulers != null) {
		for (Scheduler scheduler : mSchedulers) {
			scheduler.cancel(mWorkSpecId);
		}
		Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
	}
}
```

åœ¨ `onWorkFinished()` ä¼šå¯¹åˆšåˆšæ‰§è¡Œå®Œæ¯•çš„ä»»åŠ¡ä½œè¿›ä¸€æ­¥å¤„ç†ã€‚é¦–å…ˆè·å–ä»»åŠ¡çš„å½“å‰çŠ¶æ€ `state`ï¼Œç„¶åä» `db` ä¸­åˆ é™¤è¿™ä¸ªä»»åŠ¡ï¼Œå†æ ¹æ® `state` ä½œè¿›ä¸€æ­¥å¤„ç†ã€‚æˆ‘ä»¬çœ‹ä¸€ä¸‹ `handleResult(mResult)` çš„å®ç°ï¼š

```java
private void handleResult(ListenableWorker.Result result) {
	if (result instanceof ListenableWorker.Result.Success) {
		Logger.get().info(
				TAG,
				String.format("Worker result SUCCESS for %s", mWorkDescription));
		if (mWorkSpec.isPeriodic()) {
			resetPeriodicAndResolve();
		} else {
			setSucceededAndResolve();
		}

	} else if (result instanceof ListenableWorker.Result.Retry) {
		Logger.get().info(
				TAG,
				String.format("Worker result RETRY for %s", mWorkDescription));
		rescheduleAndResolve();
	} else {
		Logger.get().info(
				TAG,
				String.format("Worker result FAILURE for %s", mWorkDescription));
		if (mWorkSpec.isPeriodic()) {
			resetPeriodicAndResolve();
		} else {
			setFailedAndResolve();
		}
	}
}
```

- åœ¨ `handleResult()` æ–¹æ³•ä¸­ä¼šæ ¹æ®ä»»åŠ¡ç±»å‹å’Œ result ç»“æœè¿›è¡Œä¸åŒçš„å¤„ç†ã€‚ä¾‹å¦‚å‘¨æœŸæ€§çš„ä»»åŠ¡ä¼šé‡æ–°å°†è¿™ä¸ªä»»åŠ¡çš„çŠ¶æ€è®¾ç½®ä¸º `ENQUEUED`ï¼Œæ›´æ–°å…¶ä»–ç›¸å…³å‚æ•°ï¼Œå¹¶æ›´æ–°æ•°æ®åº“ã€‚
- å·²ç»å®Œæˆçš„ä¸€æ¬¡æ€§ä»»åŠ¡å°†ä¼šè¢«æ›´æ–°æˆ `SUCCEEDED` çš„çŠ¶æ€
- `handleResult()` æ‰§è¡Œå®Œæ¯•åæ›´æ–° `isWorkFinished`ã€‚å¦‚æœ `isWorkFinished` ä¸º trueï¼Œç”±äºæˆ‘ä»¬åœ¨ `GreedyScheduler` å·²ç»å¤„ç†äº†è¿™ä¸ªä»»åŠ¡ï¼Œä¸ºäº†é¿å…è¿™ä¸ªä»»åŠ¡è¢«å…¶ä»– schedulers å¤„ç†ï¼Œ`WorkManager` éå†äº† `mSchedulers` åˆ—è¡¨ï¼Œå¹¶å°†è¿™ä¸ªä»»åŠ¡ä»å…¶ä»– `schedulers` ä¸­ç§»é™¤ã€‚æœ€åå†æ¬¡æ‰§è¡Œ `Schedulers.schedule()` æ–¹æ³•ï¼Œ`schedule` ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚

#### å°ç»“

- åœ¨ WorkManager æ‰§è¡Œäº† enqueue() åï¼Œåˆ›å»º WorkContinuationImpl å¯¹è±¡æ‰§è¡Œ enqueue() æ–¹æ³•ã€‚
- WorkContinuationImpl æŒæœ‰çš„ EnqueueRunnable å¯¹è±¡å°†ä»»åŠ¡æ·»åŠ åˆ° dbï¼Œå¹¶äº¤ç»™ Schedulers å»è°ƒåº¦ã€‚
- Schedulers å°†ä»»åŠ¡äº¤ç»™æ¯ä¸€ä¸ª Scheduler å»å¤„ç†ã€‚æ²¡æœ‰çº¦æŸçš„ä¸€æ¬¡æ€§ä»»åŠ¡ï¼ŒGreedyScheduler ä¼šå…ˆå¤„ç†è¿™ä¸ªä»»åŠ¡ã€‚
- GreedyScheduler ç»è¿‡ä¸€ç³»åˆ—åˆ¤æ–­åï¼Œè°ƒç”¨ WorkManager çš„ startWork() æ–¹æ³•æ‰§è¡Œè¿™ç§ä¸€æ¬¡æ€§ï¼Œéå»¶è¿Ÿï¼Œæ— çº¦æŸçš„ä»»åŠ¡ã€‚
- WorkManager æŒæœ‰çš„ StartWorkRunnable å¯¹è±¡ä¼šå°†ä»»åŠ¡äº¤ç»™ Processor å»å¤„ç†ï¼Œæ‰§è¡Œ startWork() æ–¹æ³•ã€‚
- Processor åˆ›å»ºä¸€ä¸ª WorkerWrapper å¯¹è±¡ï¼Œç”±å®ƒå»è°ƒç”¨ Worker çš„ startWork() æ–¹æ³•ï¼Œæ‰§è¡Œæˆ‘ä»¬è‡ªå®šä¹‰ worker çš„ä»»åŠ¡ï¼Œå¹¶è¿”å›ç›¸åº”çš„ resultã€‚
- ä»»åŠ¡å®Œæˆåï¼ŒWorkerWrapper ä¼šæ ¹æ® result å¯¹ä»»åŠ¡çŠ¶æ€ï¼Œdb ç­‰è¿›è¡Œæ›´æ–°ï¼Œç„¶å schedule ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚

**æµç¨‹å›¾ï¼š**
![](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202408192346891.png)

### Periodic å‘¨æœŸä»»åŠ¡

ä½¿ç”¨ï¼š

```kotlin
WorkManager.getInstance(context)  
    .enqueueUniquePeriodicWork(  
        workerName,  
        ExistingPeriodicWorkPolicy.REPLACE,  
        workRequest  
    )
```

è¿›å…¥åˆ° `WorkManagerImpl.enqueueUniquePeriodicWork`

```java
// v2.7.1 WorkManagerImpl.java
public Operation enqueueUniquePeriodicWork(  
	@NonNull String uniqueWorkName,  
	@NonNull ExistingPeriodicWorkPolicy existingPeriodicWorkPolicy,  
	@NonNull PeriodicWorkRequest periodicWork) {  
  
    return createWorkContinuationForUniquePeriodicWork(  
            uniqueWorkName,  
            existingPeriodicWorkPolicy,  
            periodicWork)  
            .enqueue();  
}
// åˆ›å»ºäº†WorkContinuationImplï¼Œ
public WorkContinuationImpl createWorkContinuationForUniquePeriodicWork(  
        @NonNull String uniqueWorkName,  
        @NonNull ExistingPeriodicWorkPolicy existingPeriodicWorkPolicy,  
        @NonNull PeriodicWorkRequest periodicWork) {  
    ExistingWorkPolicy existingWorkPolicy;  
    if (existingPeriodicWorkPolicy == ExistingPeriodicWorkPolicy.KEEP) {  
        existingWorkPolicy = ExistingWorkPolicy.KEEP;  
    } else {  
        existingWorkPolicy = ExistingWorkPolicy.REPLACE;  
    }  
    return new WorkContinuationImpl(  
            this,  
            uniqueWorkName,  
            existingWorkPolicy,  
            Collections.singletonList(periodicWork));  
}
```

ç„¶åè°ƒç”¨äº† `WorkManagerImpl.enqueue()`ï¼š

```java
// v2.7.1 WorkManagerImpl.java
@Override  
public @NonNull Operation enqueue() {  
    if (!mEnqueued) {  
	    // åˆ›å»ºä¸€ä¸ªEnqueueRunnable
	    EnqueueRunnable runnable = new EnqueueRunnable(this);
        mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(runnable);  
        mOperation = runnable.getOperation();  
    } else {  
        Logger.get().warning(TAG,  
                String.format("Already enqueued work ids (%s)", TextUtils.join(", ", mIds)));  
    }  
    return mOperation;  
}
```

åœ¨ `TaskExecutor` ä¸­æ‰§è¡Œ `EnqueueRunnable`ï¼Œçœ‹ `run()` æ–¹æ³•

```java
// EnqueueRunnable.java
@Override  
public void run() {  
    try {  
        // ... 
        boolean needsScheduling = addToDatabase();  // å°†Workerä¿¡æ¯å­˜å‚¨åˆ°æ•°æ®åº“ä¸­å»
        if (needsScheduling) {  
            // Enable RescheduleReceiver, only when there are Worker's that need scheduling.  
            final Context context = mWorkContinuation.getWorkManagerImpl().getApplicationContext();  
            PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, true);  
            scheduleWorkInBackground();  
        }  
        mOperation.setState(Operation.SUCCESS);  
    } catch (Throwable exception) {  
        mOperation.setState(new Operation.State.FAILURE(exception));  
    }  
}
// å®‰æ’æ‰§è¡Œ
public void scheduleWorkInBackground() {  
    WorkManagerImpl workManager = mWorkContinuation.getWorkManagerImpl();  
    Schedulers.schedule(  
            workManager.getConfiguration(),  
            workManager.getWorkDatabase(),  
            workManager.getSchedulers());  
}
```

çœ‹ `Schedulers.schedule()`

```java
// Schedulers.java
public static void schedule(Configuration configuration, WorkDatabase workDatabase, List<Scheduler> schedulers) {  
    // ...
  
    WorkSpecDao workSpecDao = workDatabase.workSpecDao();  
    List<WorkSpec> eligibleWorkSpecsForLimitedSlots;  
    List<WorkSpec> allEligibleWorkSpecs;  
  
    workDatabase.beginTransaction();  
    try {  
        // Enqueued workSpecs when scheduling limits are applicable.  
        eligibleWorkSpecsForLimitedSlots = workSpecDao.getEligibleWorkForScheduling(  
                configuration.getMaxSchedulerLimit());  
  
        // Enqueued workSpecs when scheduling limits are NOT applicable.  
        allEligibleWorkSpecs = workSpecDao.getAllEligibleWorkSpecsForScheduling(  
                MAX_GREEDY_SCHEDULER_LIMIT);  
  
        if (eligibleWorkSpecsForLimitedSlots != null  
                && eligibleWorkSpecsForLimitedSlots.size() > 0) {  
            long now = System.currentTimeMillis();  
  
            // Mark all the WorkSpecs as scheduled.  
            // Calls to Scheduler#schedule() could potentially result in more schedules            // on a separate thread. Therefore, this needs to be done first.            for (WorkSpec workSpec : eligibleWorkSpecsForLimitedSlots) {  
                workSpecDao.markWorkSpecScheduled(workSpec.id, now);  
            }  
        }  
        workDatabase.setTransactionSuccessful();  
    } finally {  
        workDatabase.endTransaction();  
    }  
  
    if (eligibleWorkSpecsForLimitedSlots != null  
            && eligibleWorkSpecsForLimitedSlots.size() > 0) {  
  
        WorkSpec[] eligibleWorkSpecsArray =  
                new WorkSpec[eligibleWorkSpecsForLimitedSlots.size()];  
        eligibleWorkSpecsArray =  
                eligibleWorkSpecsForLimitedSlots.toArray(eligibleWorkSpecsArray);  
  
        // Delegate to the underlying schedulers.  
        for (Scheduler scheduler : schedulers) {  
            if (scheduler.hasLimitedSchedulingSlots()) {  
                scheduler.schedule(eligibleWorkSpecsArray);  
            }  
        }  
    }  
  
    if (allEligibleWorkSpecs != null && allEligibleWorkSpecs.size() > 0) {  
        WorkSpec[] enqueuedWorkSpecsArray = new WorkSpec[allEligibleWorkSpecs.size()];  
        enqueuedWorkSpecsArray = allEligibleWorkSpecs.toArray(enqueuedWorkSpecsArray);  
        // Delegate to the underlying schedulers.  
        for (Scheduler scheduler : schedulers) {  
            if (!scheduler.hasLimitedSchedulingSlots()) {  
                scheduler.schedule(enqueuedWorkSpecsArray);  
            }  
        }  
    }  
}
```

`Schedulers.schedule()` æŸ¥è¯¢çŠ¶æ€æ˜¯ `ENQUEUED = 0` çš„ä»»åŠ¡æ‰§è¡Œ

## çº¦æŸæ¡ä»¶ä»»åŠ¡çš„æ‰§è¡Œè¿‡ç¨‹

**å¸¦çº¦æŸæ¡ä»¶ä½¿ç”¨ç¤ºä¾‹ï¼š**

```kotlin
val constraints = Constraints.Builder()
	.setRequiresBatteryNotLow(true)
	.build()
val work2Request = OneTimeWorkRequestBuilder<Worker2>()
	.setConstraints(constraints)
	.build()
WorkManager.getInstance(this).enqueue(work2Request)
```

ä»»åŠ¡çš„åˆ›å»ºè¿‡ç¨‹ä¸­ï¼Œä¼šä¸º `WorkSpec` æ·»åŠ  `Constraints` å±æ€§ã€‚

```java
public final @NonNull B setConstraints(@NonNull Constraints constraints) {
	mWorkSpec.constraints = constraints;
	return getThis();
}
```

åœ¨ä»»åŠ¡æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œç”±äºå¢åŠ äº†çº¦æŸæ¡ä»¶ï¼Œæ ¹æ®ä¹‹å‰ç« èŠ‚çš„åˆ†æï¼Œå¸¸é©»çš„ `GreedyScheduler` çš„ `schedule()` æ–¹æ³•å°†ä¸ä¼š `startWork()`ï¼Œè€Œæ˜¯æ ¹æ® **build version** äº¤ç”± **SystemJobScheduler** æˆ– **SystemAlarmScheduler** è¿›è¡Œå¤„ç†ã€‚å…ˆæ¥çœ‹ä½¿ç”¨ `SystemJobScheduler` çš„æƒ…å†µ:

### **SystemJobScheduler (Build Version å¤§äºç­‰äº 23)**

`SystemJobScheduler` ä½¿ç”¨çš„æ˜¯ `JobScheduler` æ¥è°ƒåº¦æ‰§è¡Œä»»åŠ¡ã€‚é€šå¸¸ `JobScheduler` çš„ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹:

1. åˆ›å»º `JobService`
2. é…ç½® `JobInfo`
3. æ‰§è¡Œ

#### SystemJobService

`SystemJobService` æ˜¯æ‰§è¡Œä»»åŠ¡çš„æœåŠ¡ç±»ï¼Œåœ¨ `onStartJob()` ä¸­ï¼Œä¼šè°ƒç”¨ `WorkManagerImpl` çš„ `startWork()` æ‰§è¡Œä»»åŠ¡ã€‚

```java
// SystemJobService
@Override
public boolean onStartJob(@NonNull JobParameters params) {
	// ... ...
	String workSpecId = getWorkSpecIdFromJobParameters(params);
	// ... ...
	synchronized (mJobParameters) {
	  // ... ...
		mJobParameters.put(workSpecId, params);
	}
	// ... ...
	mWorkManagerImpl.startWork(workSpecId, runtimeExtras);
	return true;
}
```

åœ¨åˆå§‹åŒ– `SystemJobScheduler` çš„æ—¶å€™ä¼šè·å– `JobScheduler` å¯¹è±¡:

```java
// SystemJobScheduler 
public SystemJobScheduler(@NonNull Context context, @NonNull WorkManagerImpl workManager) {
	this(context,
		workManager,
		(JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE),
		new SystemJobInfoConverter(context));
}
```

`SystemJobScheduler` çš„ `schedule()` æ–¹æ³•æ‰§è¡Œäº† `scheduleInternal()`:

```java
// SystemJobScheduler
public void scheduleInternal(WorkSpec workSpec, int jobId) {
	JobInfo jobInfo = mSystemJobInfoConverter.convert(workSpec, jobId);
	Logger.get().debug(
			TAG,
			String.format("Scheduling work ID %s Job ID %s", workSpec.id, jobId));
	try {
		mJobScheduler.schedule(jobInfo);
	} catch (IllegalStateException e) {
		... ...
		throw new IllegalStateException(message, e);
	} catch (Throwable throwable) {
		// OEM implementation bugs in JobScheduler cause the app to crash. Avoid crashing.
		Logger.get().error(TAG, String.format("Unable to schedule %s", workSpec), throwable);
	}
}
```

`SystemJobInfoConverter.convert()` æ–¹æ³•å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ª `JobInfo`ï¼Œå¹¶å°† `Constraints` é‡Œçš„çº¦æŸæ¡ä»¶èµ‹äºˆ `JobInfo` å¯¹è±¡ï¼Œä¹‹åä¾¿æ‰§è¡Œäº† `JobScheduler.schedule()`ï¼Œæ ¹æ®çº¦æŸæ¡ä»¶å¯¹ä»»åŠ¡è¿›è¡Œè°ƒåº¦ã€‚

### SystemAlarmScheduler (Build Version å°äº 23)

`SystemAlarmScheduler` ä½¿ç”¨çš„æ˜¯ `AlarmManager` æ¥è°ƒåº¦æ‰§è¡Œä»»åŠ¡ã€‚åœ¨ `AndroidManifest` é‡Œæœ‰å¦‚ä¸‹ `receiver` æ³¨å†Œ:

```java
<receiver android:directBootAware="false" android:enabled="false" android:exported="false" android:name="androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryNotLowProxy">
    <intent-filter>
          <action android:name="android.intent.action.BATTERY_OKAY"/>
          <action android:name="android.intent.action.BATTERY_LOW"/>
    </intent-filter>
</receiver>
```

åœ¨ç”µé‡å˜åŒ–æ—¶ï¼Œæ”¶åˆ° `BATTERY_LOW` çš„å¹¿æ’­ã€‚åœ¨ `BatteryNotLowProxy` çš„ `onReceive()` è¿›è¡Œå¤„ç†ï¼š

```java
// ConstraintProxy
public static class BatteryNotLowProxy extends ConstraintProxy {
}

@Override
public void onReceive(Context context, Intent intent) {
	Logger.get().debug(TAG, String.format("onReceive : %s", intent));
	Intent constraintChangedIntent = CommandHandler.createConstraintsChangedIntent(context);
	context.startService(constraintChangedIntent);
}
```

`createConstraintsChangedIntent()` çš„æ‰§è¡Œå¦‚ä¸‹:

```java
// ConstraintProxy
static Intent createConstraintsChangedIntent(@NonNull Context context) {
	Intent intent = new Intent(context, SystemAlarmService.class);
	intent.setAction(ACTION_CONSTRAINTS_CHANGED);
	return intent;
}
```

`SystemAlarmService` çš„ `onStartCommand()` å¤„ç†å¦‚ä¸‹:

```java
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
	super.onStartCommand(intent, flags, startId);
	// ... ...
	if (intent != null) {
		mDispatcher.add(intent, startId);
	}
	// If the service were to crash, we want all unacknowledged Intents to get redelivered.
	return Service.START_REDELIVER_INTENT;
}
```

è°ƒç”¨äº† `SystemAlarmDispatcher.add()` æ–¹æ³•ã€‚

```java
// SystemAlarmDispatcher
@MainThread
public boolean add(@NonNull final Intent intent, final int startId) {
	// ... ...
	if (CommandHandler.ACTION_CONSTRAINTS_CHANGED.equals(action)
			&& hasIntentWithAction(CommandHandler.ACTION_CONSTRAINTS_CHANGED)) {
		return false;
	}
	intent.putExtra(KEY_START_ID, startId);
	synchronized (mIntents) {
		boolean hasCommands = !mIntents.isEmpty();
		mIntents.add(intent);
		if (!hasCommands) {
			// Only call processCommand if this is the first command.
			// The call to dequeueAndCheckForCompletion will process the remaining commands
			// in the order that they were added.
			processCommand();
		}
	}
	return true;
}
```

`add()` æ–¹æ³•ä¸­æ‰§è¡Œäº† `processCommand()`ï¼Œè¿™æ®µä»£ç çš„æ ¸å¿ƒæ‰§è¡Œè¯­å¥æ˜¯:

```java
// SystemAlarmDispatcher
mCommandHandler.onHandleIntent(mCurrentIntent, startId, SystemAlarmDispatcher.this);
```

åœ¨ `CommandHandler` çš„ `onHandleIntent()` æ–¹æ³•ä¸­ï¼Œ`action` ä¸º `ACTION_CONSTRAINTS_CHANGED` çš„æ‰§è¡Œæ˜¯:

```java
// CommandHandler
if (ACTION_CONSTRAINTS_CHANGED.equals(action)) {
	handleConstraintsChanged(intent, startId, dispatcher);
} 
private void handleConstraintsChanged(
		@NonNull Intent intent, int startId,
		@NonNull SystemAlarmDispatcher dispatcher) {

	Logger.get().debug(TAG, String.format("Handling constraints changed %s", intent));
	// Constraints changed command handler is synchronous. No cleanup
	// is necessary.
	ConstraintsCommandHandler changedCommandHandler =
			new ConstraintsCommandHandler(mContext, startId, dispatcher);
	changedCommandHandler.handleConstraintsChanged();
}
```

åœ¨ `handleConstraintsChanged()` æ–¹æ³•çš„æ‰§è¡Œä¸­ï¼Œä¼šåˆ›å»ºä¸€ä¸ª `action` ä¸º `ACTION_DELAY_MET` çš„ `Intent` ç„¶åç”± `SystemAlarmDispatcher` å‘é€å‡ºå»ï¼Œå®é™…ä¸Šä¹Ÿæ˜¯è°ƒç”¨äº† `SystemAlarmDispatcher.add()` æ–¹æ³•ã€‚å›åˆ° `SystemAlarmDispatcher` çš„ `add()` æµç¨‹ã€‚

```java
// ConstraintsCommandHandler
Intent intent = CommandHandler.createDelayMetIntent(mContext, workSpecId);
Logger.get().debug(TAG, String.format("Creating a delay_met command for workSpec with id (%s)", workSpecId));
mDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(mDispatcher, intent, mStartId));
```

å›åˆ° `onHandleIntent()` æ–¹æ³•ï¼Œåœ¨ `CommandHandler` çš„ `onHandleIntent()` æ–¹æ³•ä¸­ï¼Œaction ä¸º `ACTION_DELAY_MET` çš„æ‰§è¡Œæ˜¯ï¼š

```java
// CommandHandler
else if (ACTION_DELAY_MET.equals(action)) {
	handleDelayMet(intent, startId, dispatcher);
} 
```

`handleDelayMet()` çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œä¼šè°ƒç”¨ `DelayMetCommandHandler` çš„ `handleProcessWork()` æ–¹æ³•ï¼Œæ¥ç€æ‰§è¡Œ `onAllConstraintsMet()`ï¼š

```java
@Override
public void onAllConstraintsMet(@NonNull List<String> workSpecIds) {
	// ... ...
	synchronized (mLock) {
		if (mCurrentState == STATE_INITIAL) {
			// ... ...
			boolean isEnqueued = mDispatcher.getProcessor().startWork(mWorkSpecId);
			// ... ...
		} else {
			Logger.get().debug(TAG, String.format("Already started work for %s", mWorkSpecId));
		}
	}
}
```

`SystemAlarmDispatcher` è°ƒç”¨äº† `Processor` çš„ `startWork()` æ–¹æ³•

# Ref

- [x] [WorkManager æµç¨‹åˆ†æå’Œæºç è§£æ | å¼€å‘è€…è¯´Â·DTalk](https://mp.weixin.qq.com/s/MPZD9LbSbJYx1BLAolIbIg)
