---
banner: 
date_created: Thursday, March 6th 2025, 8:45:12 am
date_updated: Thursday, March 6th 2025, 9:10:23 am
title: Window
author: hacket
categories: 
category: 
tags: []
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
aliases: [Window]
linter-yaml-title-alias: Window
---

# Window

## Window

### Window 是什么？

Window 是一个窗口的概念，是所有 View 的直接管理者，任何视图都通过 Window 呈现 (如 Activity 和 Dialog 都是 PhoneWindow)，点击事件由 Window→DecorView→View。

### Window 机制

- Window 机制就是为了管理屏幕上的 view 的显示以及触摸事件的传递问题
- Window 是一个抽象类，唯一实现类 PhoneWindow
- 一个 Window 对应着一个 ViewRootImpl，Window 和 View 是通过 ViewRootImpl 建立联系的
- Window 并不是实际存在的，而是以 View 的形式存在；View 是视图的呈现方式，不能单独存在，必须依附在 Window 这个抽象的概念上
- 实际使用中无法直接访问 Window，必须通过 WindowManager，WindowManager 的实现是 WindowManagerImpl，最终是通过 WMS 交互（IPC）

### 窗口的层级与类型

通过 `WindowManager.LayoutParams.type` 定义窗口类型，决定了窗口的层级和用途：

| **类型**     | **值范围**    | **示例**                                     |
| ---------- | ---------- | ------------------------------------------ |
| **应用窗口**   | 1~99       | Activity、Dialog（`TYPE_APPLICATION`）        |
| **子窗口**    | 1000~1999  | PopupWindow（`TYPE_APPLICATION_PANEL`）      |
| **系统窗口**   | 2000~2999  | 状态栏（`TYPE_STATUS_BAR`）、Toast（`TYPE_TOAST`） |
| **系统级悬浮窗** | 2000+（需权限） | `TYPE_APPLICATION_OVERLAY`                 |

**层级规则：**
- 类型值越大，窗口层级越高（显示在上层）
- 系统窗口始终覆盖应用窗口。

## 和 WMS、Activity 及 View 的关系

### Window、WindowManager 和 WMS 关系

- Window 是一个抽象类，并不是真实存在，唯一实现是 PhoneWindow，它对 View 进行管理；
- WindowManager 是一个接口类，用来管理 Window 的，实现类是 WindowManagerImpl，用来对 Window 进行添加、更新和删除；
- WindowManager 会将具体的工作交由 WMS 来处理，WindowManager 和 WMS 通过 Binder 来进行 IPC 通信，WMS 作为系统服务还有很多 API 不会暴露给 WindowManager 的。

**Window、WindowManager 和 WMS 关系图：**![srhqu](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/srhqu.png)

#### Window

- **定义**：一个抽象类，代表一个「窗口」，是 Android 屏幕内容的基本容器。
	
- **作用**：
	- 承载和管理 `View`（通过 `DecorView`）。
	- 定义窗口的属性（如宽高、位置、层级、透明度等）。
	- 处理输入事件的分发。
		
- **实现类**：
	- `PhoneWindow`：唯一的实现类，每个 Activity 或 Dialog 对应一个 `PhoneWindow`。

#### WindowManager

- **定义**：接口类，负责窗口的添加、删除、更新。
- **实现类**：`WindowManagerImpl`，内部通过 `WindowManagerGlobal` 与系统服务通信。
- **核心方法**：

```java
void addView(View view, WindowManager.LayoutParams params); // 添加窗口
void updateViewLayout(View view, WindowManager.LayoutParams params); // 更新窗口参数
void removeView(View view); // 删除窗口
```

#### ViewRootImpl

- **作用**：
	- 连接 `Window` 和 `View` 的桥梁。
	- 管理 `View` 的测量、布局、绘制流程。
	- 通过 `Choreographer` 协调 VSYNC 信号，驱动 UI 刷新。
	- 与 `Surface` 交互，将内容渲染到屏幕上。

#### WindowManagerService (WMS)

- **系统服务**：运行在系统进程中，管理所有应用的窗口。
- **职责**：
	- 窗口层级（Z-Order）的排序。
	- 窗口的焦点分配。
	- 与 `SurfaceFlinger` 协作合成最终屏幕内容。

### Activity、Window、DecorView 和 View 之间的关系

每个 Activity 包含了一个 Window 对象，这个对象是由 PhoneWindow 实现的。而 PhoneWindow 将 DecorView 作为了一个应用窗口的根 View，这个 DecorView 又把屏幕划分为了两个区域：一个是 TitleView，也就是 ActionBar 或者 TitleBar，一个是 ContentView，而我们平时在 Xml 文件中写的布局正好是展示在 ContentView 中的。<br />![c5fqp](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/c5fqp.png)
