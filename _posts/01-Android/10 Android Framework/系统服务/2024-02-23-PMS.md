---
date_created: Friday, February 23rd 2024, 10:10:45 pm
date_updated: Wednesday, January 22nd 2025, 12:39:34 am
title: PMS
author: hacket
categories: 
category: 
tags: []
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:40
date updated: 2024-12-24 00:40
aliases: [Android apk]
linter-yaml-title-alias: Android apk
---

# Android apk

## apk 包编译流程

![](https://cdn.nlark.com/yuque/0/2022/webp/694278/1655785715919-1fb4f7b5-3d1e-4d82-8646-eaeb97151285.webp#averageHue=%23fbfbfb&clientId=u4b8a14ca-98b9-4&from=paste&id=ub8ea8f3d&originHeight=882&originWidth=536&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1514da89-43cc-4436-9ecb-2d249b1ca99&title=)

### 1、Java 文件编译成.class 文件 javac

#### 打包资源文件，生成 R.java 文件

**工具：aapt(The Android Asset Packing Tool)**

1. res 目录下资源文件 (layout/drawable/color 等) 都会编译，然后生成相应的 R.java
2. AndroidManifest.xml 会被 aapt 编译成二进制。
3. aapt 工具会对资源文件进行编译，并生成一个 resource.arsc 文件，resource.arsc 文件相当于一个文件索引表，记录了很多跟资源相关的信息。

#### 处理 aidl 文件，生成相应的 Java 文件

**工具：aidl（Android Interface Definition Language）**<br />aidl 工具解析接口定义文件然后生成相应的 Java 代码接口供程序调用。

#### 编译项目源代码，生成 class 文件

**工具：Java 编译器（javac）**<br />项目中所有的**Java 代码**，包括**R.java**和**.aidl**文件，都会变 Java 编译器（javac）编译成.class 文件，生成的 class 文件位于工程中的 bin/classes 目录下。

### 2、转换所有的 class 文件，生成 classes.dex 文件 dex 工具

**工具：dx（dex）**<br />生成可供 Android 系统 Dalvik 虚拟机执行的 classes.dex 文件<br />任何第三方的 libraries 和.class 文件都会被转换成.dex 文件。dx 工具的主要工作是将 Java 字节码转成 Dalvik 字节码、压缩常量池、消除冗余信息等。

> Gradle Transform 工作在这一阶段

### 3、打包生成 APK 文件 apkbuilder

**工具：apkbuilder**<br />所有没有编译的资源，如 images、assets 目录下资源（该类文件是一些原始文件，APP 打包时并不会对其进行编译，而是直接打包到 APP 中，对于这一类资源文件的访问，应用层代码需要通过文件名对其进行访问）；<br />编译过的资源和.dex 文件都会被 apkbuilder 工具打包到最终的.apk 文件中。

### 4、对 APK 文件进行签名 jarsigner

**工具：jarsigner**<br />一旦 APK 文件生成，它必须被签名才能被安装在设备上。

### 5、对签名后的 APK 文件进行对齐处理 zipalign

**工具：zipalign**<br />对齐的主要过程是将 APK 包中所有的资源文件距离文件起始偏移为 4 字节整数倍，这样通过内存映射 mmap 访问 apk 文件时的速度会更快。对齐的作用就是减少运行时内存的使用。

## apk 安装流程

安装其实就是把 apk 文件拷贝到对应的目录。

1. 复制 apk 到/data/app 目录下，解压并扫描安装包
2. 资源管理器解析 apk 里的资源文件
3. 解析 Manifest 文件，并在/data/data 目录下创建对应的应用数据目录
4. 然后对 dex 文件进行优化（Dalvik 会将 dex 处理成 odex，ART 会将 dex 处理成 oat，oat 包含 dex 和安装时编译的机器码），并保存在 dalvik-cache 目录
5. 将 Manifest 文件解析出的四大组件信息注册到 PMS 中
6. 安装完成后，发送广播

# PMS

## 什么是 PMS？

PackageManagerService（简称 PMS），包管理服务，是 Android 系统核心服务之一。负责应用程序的安装，卸载，信息查询等工作。<br />**包管理机制**<br />包指的是**Apk**、**jar**和**so 文件**等等，它们被加载到 Android 内存中，由一个包转变成可执行的代码，这就需要一个机制来进行包的加载、解析、管理等操作，这就是**包管理机制**。

## PMS 主要功能

1. 解析 Manifest 文件，解析清单中所有节点信息（主要是包括四大组件）
2. 扫描 apk 文件，安装系统应用，安装本地应用等
3. 管理本地应用，安装、卸载和应用信息查询等

## PMS 初始化流程

初始化分为 5 个阶段：

1. BOOT_PROGRESS_**PMS_START**阶段
   - 构造 Settings 类：这个是 Android 的全局管理者，用于协助 PMS 保存所有的安装包信息;
   - 保存 Installer 对象；
   - 初始化 SystemConfig，获取系统配置信息，包括全局属性、groupid 以及系统权限。初始化一些功能类，包括：PackageDexOptimizer （dex 优化工具类） 、 DexManager（dex 管理类）、PackageHandler（建立 package 相关操作的消息循环）等；
   - 创建 data 下的各种目录，比如 data/app, data/app-private 等。
2. BOOT_PROGRESS_**PMS_SYSTEM_SCAN_START**阶段
   - 通过 scanDirTracedLI 扫描系统目录文件，包括：/system/framework 、/system/priv-app 、/system/app 这俩都是放系统 app、/vendor/overlay、/vendor/app、oem/app。
3. BOOT_PROGRESS_**PMS_DATA_SCAN_START**阶段
   - 通过 scanDirTracedLI 扫描/data/app 和/data/app-private 目录下的文件。
4. BOOT_PROGRESS_**PMS_SCAN_END**阶段
   - 将上述信息写回/data/system/packages.xml。
5. BOOT_PROGRESS_**PMS_READY**阶段
   - 创建服务 PackageInstallerService。

# PMS 面试题
