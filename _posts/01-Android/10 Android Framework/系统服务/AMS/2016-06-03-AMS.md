---
date_created: Monday, June 3rd 2016, 10:48:25 pm
date_updated: Wednesday, January 22nd 2025, 8:48:36 am
title: AMS
author: hacket
categories:
  - Android Framework
category: 系统服务
tags: [Framework基础]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:40
date updated: 2024-12-24 00:40
aliases: [AMS 基础]
linter-yaml-title-alias: AMS 基础
---

# AMS 基础

## AMS 是什么？

ActivityManagerService 是 Android 系统中一个特别重要的系统服务，也是我们上层 APP 打交道最多的系统服务之一。ActivityManagerService（以下简称 AMS） 主要负责四大组件的**启动**、**切换**、**调度**以及**应用进程的管理**和**调度**工作。所有的 APP 应用都需要与 AMS 打交道。

## AMS 的启动？

AMS 的启动是在 SystemServer 进程中启动的

- Zygote 进程 fork 出 system_server 进程
- 在 SystemServer.main 调用 startBootstrapServices()
- startBootstrapServices() 中初始化 ActivityTaskManagerService(ATMS) 和 ActivityManagerService(AMS)

## Activity 任务栈管理

![Activity 任务栈模型|500](https://cdn.nlark.com/yuque/0/2023/png/694278/1675261697496-a2d19151-72f1-4123-8ff6-67a4f660344e.png#averageHue=%23f0f0f0&clientId=uc28ac36b-2b97-4&from=paste&height=284&id=uf7c8f751&originHeight=703&originWidth=705&originalType=binary&ratio=1&rotation=0&showTitle=true&size=172634&status=done&style=none&taskId=u7ac9403e-fa0f-4529-b33f-d17e9831d01&title=Activity%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%A8%A1%E5%9E%8B&width=285 "Activity 任务栈模型")

- **ActivityRecord **存储了 Activity 的所有信息，包括 AMS 引用、Manifest 节点信息、Activity 状态、Activity 资源信息和 Activity 进程相关信息；还含有该 ActivityRecord 所在的 TaskRecord。
- **TaskRecord **描述的是一个 Activity 任务栈，存储了任务栈的所有信息，包括任务栈的唯一标识符、任务栈的倾向性、任务栈中的 Activity 记录和 AMS 引用等；还含有 ActivityStack，也就是当前 Activity 任务栈所归属的 ActivityStack。
- **ActivityStack ** 管理系统所有 Activity，维护了 Activity 的所有状态

> ActivityRecord 用来记录一个 Activity 的所有信息，TaskRecord 中包含一个或多个 ActivityRecord，TaskRecord 用来表示 Activity 任务栈，用来管理栈中的 ActivityRecord；而 ActivityStack 又包含了一个或多个 TaskRecord，它是 TaskRecord 的管理者，ActivityStack 包含一个或多个 TaskRecord。

## 点击一个 APP 到 View 呈现中间发生了什么？

## ![image.png](https://cdn.nlark.com/yuque/0/2022/png/694278/1653789472233-e5816808-dc7b-4c05-9282-59e8cfc81662.png#averageHue=%23e2e7c6&clientId=ud99087df-b2c8-4&from=paste&height=641&id=ub2907756&originHeight=961&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&size=565409&status=done&style=none&taskId=u105e394f-139e-485f-8a42-72e2fa54635&title=&width=951.3333333333334)

### 1、Launcher 进程 start 目标 Activity

Launcher 进程通过 ATMS(ATMSsystem_server 进程) 启动目标 Activity，这个过程涉及了 IPC，通过 binder 机制。<br>具体通过 Activity/Instrumentatation/ATMS/ActivityStarter/RootWindowContainer 等一串调用链条。

- Instrumentation：监控应用与系统相关的交互行为
- AMS：组件管理调度中心，四大组件的生命周期
- ActivityStarter：Activity 启动的控制器，处理 Intent 与 Flag 对 Activity 启动的影响
- ActivityStackSupervisior：用来管理多个任务栈，高版本才有。用来管理多个 ActivityStack，
- ActivityStack：用来管理任务栈里的 Activity
- ActivityThread：Activity、Service、BroadcastReceiver 的启动、切换、调度和各种操作都在这个类完成

**system_server 进程如何启动的？**

> system_server 进程是 Zygote 进程孵化的第一个 Java 进程，主要用来启动系统的服务，几十个

**ATMS 和 AMS 的拆分，ATMS 的作用？**

> Android10 及以上，AMS 拆分了，将 Activity 相关的转移到了 ATMS 中处理

**servicemanager 是如何管理系统服务的 (binder 大总管)？如何启动的（init.rc 启动的）？，管理所有 binder server 服务**

### 2、ATMS 处理：ATMS 处理请求及通过 socket 让 Zygote 进程 fork 一个 App 进程，可选

ATMS 收到启动请求后，交付 ActivityStarter 处理 Intent 和 Flag 等信息，然后交给 ActivityStackSupervisor/ActivityStack 处理 Activity 进栈相关流程；同时以 Socket 方式请求 Zygote 进程 fork 出应用进程。<br>如果目标 Activity 的进程未启动，ATMS 会请求 Zygote 进程启动需要的应用程序进程。

### 3、Zygote fork 应用进程 (如何需要的话)

Zygote 进程 fork 出 App 进程，在新进程里反射创建 ActivityThread 对象调用 main，这个就是应用的主线程，在主线程里开启 Looper 消息循环，开始处理创建 Activity。

- 创建 application, 这里又通过 Binder，attachApplication 到 ATMS，把 ApplicationThread 传递给了 AMS(App 进程的 BinderProxy)

> 匿名 Binder，利用 AMS，在 attachApplication 将 ApplicationThread 带给了 AMS，这样 AMS 就可以和 App 进程通信了

- ActivityThread 利用 ClassLoader 去加载 Activity，创建 Activity 实例，并回调 Activity 的 onCreate()

**Zygote 进程如何启动？作用？**<br>Zygote 进程是 init 进程 fork 启动的，Zygote 进程会启动 Android 虚拟机，加载一些系统资源，fork 出 system_server 进程和应用进程。<br>**为什么通过 Zygote 创建进程的 IPC 不是用 Binder 而是 Socket？**

> 1. binder 是多线程，fork 不允许多线程，容易出现死锁
> 2. 繁琐，要打开 binder 驱动，注册到 ServiceManager 中，AMS 再从 ServiceManager 拿 Zygote 的 binder 代理对象

- Zygote Java 进程启动后，会创建一个 ZygoteServer 端的 Socket，这个 Socket 会等待 AMS 请求 Zygote 来创建新的进程
- Zygote 进程 fork 出应用进程，应用进程就会获得 Zygote 进程在启动时创建的虚拟机实例，还会创建 Binder 线程池和消息循环，这样运行在应用进程中的应用程序就可以方便地使用 Binder 进行进程间通信及消息处理了，

### 4、AMS 通过 ApplicationThreadProxy 调用 App 进程的 Activity.onCreate

### 5、交给 WMS 处理

![](https://cdn.nlark.com/yuque/0/2022/webp/694278/1654103136436-bb5b3843-811d-41af-a56d-923392a08b0f.webp?x-oss-process=image%2Fresize%2Cw_1125%2Climit_0#averageHue=%23f7f4e4&from=url&id=EzRWV&originHeight=305&originWidth=1125&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=)

# AMS 相关面试题

## 1、从 Activity 创建到 View 呈现中间发生了什么？

<https://mp.weixin.qq.com/s?__biz=MzU4NDc1MjI4Mw==&mid=2247483864&idx=1&sn=ca212f527ed4d29e1910d689f2f69b0e&chksm=fd944c2ccae3c53a36432164917d8c1d7d447204e036dd08ffb3d7fea43526ecdc8df87d0668&token=917258391&lang=zh_CN&scene=21#wechat_redirect>

## 2、Activity onStop 延迟 10 秒？

## 3、ANR 弹框的原理是什么？
