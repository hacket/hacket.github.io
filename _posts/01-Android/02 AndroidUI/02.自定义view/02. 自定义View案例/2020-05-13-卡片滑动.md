---
banner: 
date_created: Tuesday, May 13th 2020, 1:01:05 am
date_updated: Tuesday, May 13th 2025, 1:02:29 am
title: 上下轮播
author: hacket
categories: 
category: 
tags: 
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
aliases:
  - Untitled
linter-yaml-title-alias: Untitled
---

# 上下轮播

## 自定义 LinearLayout
```java
// VerticalFlipperView
class VerticalFlipperView @JvmOverloads constructor(
        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : LinearLayout(context, attrs, defStyleAttr), DefaultLifecycleObserver, View.OnClickListener {

    private var mFlContentNow: LinearLayout
    private var mFlContentDown: LinearLayout

    private var mLimit = 1 // 可见条目数量
    private var mDurationTime = 0L // 动画执行时间
    private var mPeriodTime = 0L // 间隔时间

    private var mScrollHeight: Int = 0 // 滚动高度（控件高度）

    private var mOnItemClickListener: OnItemClickListener? = null
    private var mVerticalFlipperAdapter: VerticalFlipperAdapter? = null

    private var mDataIndex = 0
    private var isBoundData = false // 是否已经第一次绑定过数据
    private var isCancel = false // 是否停止滚动动画

    private var mScrappedView: View? = null

    companion object {
        private const val TAG = "VerticalFlipperView"
        private const val MSG_SET_DATA = 1
        private const val MSG_SCROLL = 2
        private const val MSG_UPDATE_DATA = 3
    }

    @SuppressLint("HandlerLeak")
    private val mHandler = object : Handler() {
        override fun handleMessage(msg: Message) {
            when (msg.what) {
                MSG_SET_DATA -> {
                    boundData(true)
                }
                MSG_SCROLL -> {
                    // 继续动画
                    startFlipperAnimation()
                }
                MSG_UPDATE_DATA -> {

                }
            }
        }
    }

    fun getContentView(): List<View> {
        val views = mutableListOf<View>()
        for (i in 0 until mFlContentNow.childCount) {
            val view = mFlContentNow.getChildAt(i)
            views.add(view)
        }
        for (i in 0 until mFlContentDown.childCount) {
            val view = mFlContentDown.getChildAt(i)
            views.add(view)
        }
        return views
    }

    fun bindLifecycle(owner: LifecycleOwner?): VerticalFlipperView {
        owner?.lifecycle?.addObserver(this)
        return this
    }

    private fun boundData(isFirst: Boolean) {
        val adapter = mVerticalFlipperAdapter
        if (adapter == null || adapter.getCount() <= 0) {
            return
        }
        if (isFirst) {
            isBoundData = true
            mFlContentNow.removeAllViews()
            for (i in 0 until mLimit) {
                if (mDataIndex >= adapter.getCount()) {
                    mDataIndex = 0
                }
                val view = adapter.getView(mScrappedView, mFlContentNow, mDataIndex)
                view.setOnClickListener(this)
                mFlContentNow.addView(view, params_ll_m_w)
                mDataIndex++
            }
        }

        mFlContentDown.removeAllViews()
        for (i in 0 until mLimit) {
            if (mDataIndex >= adapter.getCount()) {
                mDataIndex = 0
            }
            val view = adapter.getView(mScrappedView, mFlContentDown, mDataIndex)
            view.setOnClickListener(this)
            mFlContentDown.addView(view, params_ll_m_w)
            mDataIndex++
        }
    }

    private fun startFlipperAnimation() {
        if (isCancel) {
            LogUtils.e(TAG, "startFlipperAnimation err isCancel. isCancel=$isCancel")
            return
        }
        LogUtils.d(TAG, "startFlipperAnimation dataIndex=$mDataIndex, height=$height")
        val anim1 = ObjectAnimator.ofFloat(mFlContentNow, View.Y, mFlContentNow.y, mFlContentNow.y - height)
        val anim2 = ObjectAnimator.ofFloat(mFlContentDown, View.Y, mFlContentDown.y, mFlContentDown.y - height)
        val animSet = AnimatorSet()
        animSet.duration = mDurationTime
        animSet.playTogether(anim1, anim2)
        animSet.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                super.onAnimationEnd(animation)

                if (mFlContentNow.childCount > 0) {
                    mScrappedView = mFlContentNow.getChildAt(0)
                }

                mFlContentNow.y = height.toFloat()
                mFlContentDown.y = 0F
                val temp = mFlContentNow
                mFlContentNow = mFlContentDown
                mFlContentDown = temp
                boundData(false)
                mHandler.sendEmptyMessageDelayed(MSG_SCROLL, mPeriodTime)
            }
        })
        animSet.start()
    }

    fun startScroll() {
        val adapter = mVerticalFlipperAdapter
        if (adapter == null || adapter.getCount() <= 0) {
            return
        }
        if (!isBoundData) {
            mHandler.sendEmptyMessage(MSG_SET_DATA)
        }
        isCancel = false
        if (adapter.getCount() > 1) {  // 不大于1数量都不需要做动画
            mHandler.removeMessages(MSG_SCROLL)   // 先清空所有滚动消息，避免滚动错乱
            mHandler.sendEmptyMessageDelayed(MSG_SCROLL, mPeriodTime)
        }
    }

    fun stopScroll() {
        isCancel = true
    }

    override fun onClick(v: View?) {
        v?.let {
            mOnItemClickListener?.onItemClick(it, mDataIndex, it.tag)
        }
    }

    override fun onStart(owner: LifecycleOwner) {
        super.onStart(owner)
        LogUtils.i(TAG, "onStart startScroll isCancel=$isCancel, dataIndex=$mDataIndex")
        if (isCancel) {
            startScroll()
        }
    }

    override fun onStop(owner: LifecycleOwner) {
        super.onStop(owner)
        stopScroll()
        LogUtils.w(TAG, "onStop stopScroll isCancel=$isCancel, dataIndex=$mDataIndex")
    }

    override fun onDestroy(owner: LifecycleOwner) {
        super.onDestroy(owner)
        mHandler.removeCallbacksAndMessages(null)
        mScrappedView = null;
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        setMeasuredDimension(measuredWidth, measuredHeight / 2)
        LogUtils.d(TAG, "onMeasure measuredHeight=$measuredHeight ,height=$height ,childCount=${childCount}")
    }

    init {
        LayoutInflater.from(context).inflate(R.layout.layout_vertical_flipper, this, true)
        mFlContentNow = this.findViewById(R.id.fl_content1)
        mFlContentDown = this.findViewById(R.id.fl_content2)

        if (attrs != null) {
            val ta = context.obtainStyledAttributes(attrs, R.styleable.VerticalFlipperView)
            try {
                mLimit = ta.getInt(R.styleable.VerticalFlipperView_limit, 1)
                mDurationTime = ta.getInt(R.styleable.VerticalFlipperView_durationTime, 1000).toLong()
                mPeriodTime = ta.getInt(R.styleable.VerticalFlipperView_periodTime, 1000).toLong()
            } finally {
                ta.recycle()
            }
        }
    }

    fun setAdapter(adapter: VerticalFlipperAdapter): VerticalFlipperView {
        this.mVerticalFlipperAdapter = adapter
        mHandler.sendEmptyMessage(MSG_SET_DATA)
        return this
    }

    fun setOnItemClickListener(listener: OnItemClickListener): VerticalFlipperView {
        this.mOnItemClickListener = listener
        return this
    }

    abstract class VerticalFlipperAdapter(val verticalFlipperView: VerticalFlipperView) {
        abstract fun getCount(): Int

        /**
         * @param convertView The old view to reuse. if possible. Note: You should check that this view
         *        is non-null and of an appropriate type before using.
         * @param position Int
         */
        abstract fun getView(convertView: View?, parent: ViewGroup, position: Int): View
    }

    interface OnItemClickListener {
        fun onItemClick(view: View, position: Int, tag: Any?)
    }

}

```