---
banner: 
date_created: Friday, February 23rd 2020, 10:10:45 pm
date_updated: Wednesday, April 16th 2025, 11:49:02 pm
title: ANR案例
author: hacket
categories:
  - 性能优化
category: 卡顿
tags: [卡顿, 性能优化, ANR]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-08-06 23:54
date updated: 2024-12-24 00:38
aliases: [ANR 案例]
linter-yaml-title-alias: ANR 案例
---

# ANR 案例

## android.os.MessageQueue.nativePollOnce

一周内 top 几的 ANR：

![image.png](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/202502062323765.png)

其中 `nativePollOnce` 的 ANR 排名第一：

![image.png](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/202502062322624.png)

## SP apply ANR

- [ ] [SharedPreferences ANR 总结](https://zhuanlan.zhihu.com/p/152623807)
- [ ] [今日头条 ANR 优化实践系列 - 告别 SharedPreference 等待](https://mp.weixin.qq.com/s/kfF83UmsGM5w43rDCH544g)
- [ ] [SharedPreferences ANR问题分析 & Android8.0的优化](https://juejin.cn/post/6844904033820377096)

### 主线程加载大文件会 ANR

### Sp 主线程 getXX 方法会 ANR

### Sp 主线程调用 commit 方法 ANR

### SharedPreferences apply

案例场景复现：连送礼物过程中频繁更新免费礼物剩余个数、钻石余额，均存储于 SharedPreference，每个 put 操作并没有合并，都是一次完整的文件 IO，即使从 commit 改成 apply，也只是把写文件操作放到队列 QueuedWork 里，在 ActivityThread 的 handlePauseActivity、handleStopActivity 等方法中会等待该队列执行完毕，导致连送大量礼物过程中切 App 触发 ANR（优化为连送中更新内存，结束才更新文件）<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/694278/1654617864595-282d2b7c-ca78-4147-bd6c-84c978f4b46d.png#averageHue=%23e3e6e4&clientId=u0c647ab8-1689-4&from=paste&height=551&id=u1d1f6f33&originHeight=827&originWidth=1437&originalType=binary&ratio=1&rotation=0&showTitle=false&size=926786&status=done&style=none&taskId=u859b5363-3b0d-47a9-9d66-f738b8ff6e1&title=&width=958)<br />难点：ANR 报错都是在系统路径。可以看到调用了 `QueueWork.java`

### SP ANR 解决

#### memory Sp

用于解决 sp 在主线程写，activity/service start/stop 生命周期回调时需要等待，导致的 ANR 问题

```kotlin
/**
 * https://gist.github.com/tprochazka/d91d89ec54bd6c3c1cb46f62faf3c12c
 *
 * ANR free implementation of SharedPreferences.
 *
 * Fast fix for ANR caused by writing all non written changes on main thread during activity/service start/stop.
 *
 * Disadvantage of current implementation:
 *  - OnSharedPreferenceChangeListener is called after all changes are written to disk.
 *  - If somebody will call edit() apply() several times after each other it will also several times write whole prefs file.
 *
 *  Usage:
 *
 *  Override this method in your Application class.
 *
 *  public SharedPreferences getSharedPreferences(String name, int mode) {
 *      return NoMainThreadWriteSharedPreferences.getInstance(super.getSharedPreferences(name, mode), name);
 *  }
 *
 *  You need to override also parent activity, because if somebody will use activity context instead
 *  of the application one, he will get a different implementation, you can do something like
 *
 *  public SharedPreferences getSharedPreferences(String name, int mode) {
 *      return getApplicationContext().getSharedPreferences(name, mode);
 *  }
 *
 * @author Tomáš Procházka (prochazka)
 */
@RequiresApi(11)
class NoMainThreadWriteSharedPreferences private constructor(
    private val sysPrefs: SharedPreferences,
    val name: String
) :
SharedPreferences {

    private val preferencesCache: MutableMap<String, Any?> = HashMap()

    companion object {
        private val executor: ExecutorService = Executors.newSingleThreadExecutor()
        private val INSTANCES: MutableMap<String, NoMainThreadWriteSharedPreferences> = HashMap()

        @JvmStatic
        fun getInstance(sharedPreferences: SharedPreferences, name: String): SharedPreferences {
            return INSTANCES.getOrPut(
                name,
                { NoMainThreadWriteSharedPreferences(sharedPreferences, name) })
        }

        /**
         * Remove all instances for testing purpose.
         */
        @VisibleForTesting
        @JvmStatic
        fun reset() {
            INSTANCES.clear()
        }
    }

    init {
        /**
         * I will think about it if there is no synchronization issue. But generally, I think that it will bring no difference. Because system shared preference itself loading whole properties file to memory anyway. So preferencesCache.putAll(sysPrefs.all) is just an in-memory operation that will be much faster than loading and parsing files from the storage.
         */
        preferencesCache.putAll(sysPrefs.all)
    }

    override fun contains(key: String?) = preferencesCache[key] != null

    override fun getAll() = HashMap(preferencesCache)

    override fun getBoolean(key: String, defValue: Boolean): Boolean {
        return preferencesCache[key] as Boolean? ?: defValue
    }

    override fun getInt(key: String, defValue: Int): Int {
        return preferencesCache[key] as Int? ?: defValue
    }

    override fun getLong(key: String, defValue: Long): Long {
        return preferencesCache[key] as Long? ?: defValue
    }

    override fun getFloat(key: String, defValue: Float): Float {
        return preferencesCache[key] as Float? ?: defValue
    }

    override fun getStringSet(key: String, defValues: MutableSet<String>?): MutableSet<String>? {
        @Suppress("UNCHECKED_CAST")
        return preferencesCache[key] as MutableSet<String>? ?: defValues
    }

    override fun getString(key: String, defValue: String?): String? {
        return preferencesCache[key] as String? ?: defValue
    }

    override fun edit(): SharedPreferences.Editor {
        return Editor(sysPrefs.edit())
    }

    override fun registerOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferenceChangeListener) {
        sysPrefs.registerOnSharedPreferenceChangeListener(listener)
    }

    override fun unregisterOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferenceChangeListener) {
        sysPrefs.unregisterOnSharedPreferenceChangeListener(listener)
    }

    inner class Editor(private val sysEdit: SharedPreferences.Editor) : SharedPreferences.Editor {

        private val modifiedData: MutableMap<String, Any?> = HashMap()
        private var keysToRemove: MutableSet<String> = HashSet()
        private var clear = false

        override fun commit(): Boolean {
            submit()
            return true
        }

        override fun apply() {
            submit()
        }

        private fun submit() {
            synchronized(preferencesCache) {
                storeMemCache()
                queuePersistentStore()
            }
        }

        private fun storeMemCache() {
            if (clear) {
                preferencesCache.clear()
                clear = false
            } else {
                preferencesCache.keys.removeAll(keysToRemove)
            }
            keysToRemove.clear()
            preferencesCache.putAll(modifiedData)
            modifiedData.clear()
        }

        private fun queuePersistentStore() {
            try {
                executor.submit {
                    sysEdit.commit()
                }
            } catch (ex: Exception) {
                Log.e(
                    "NoMainThreadWritePrefs",
                    "NoMainThreadWriteSharedPreferences.queuePersistentStore(), submit failed for $name"
                )
            }
        }

        override fun remove(key: String): SharedPreferences.Editor {
            keysToRemove.add(key)
            modifiedData.remove(key)
            sysEdit.remove(key)
            return this
        }

        override fun clear(): SharedPreferences.Editor {
            clear = true
            sysEdit.clear()
            return this
        }

        override fun putLong(key: String, value: Long): SharedPreferences.Editor {
            modifiedData[key] = value
            sysEdit.putLong(key, value)
            return this
        }

        override fun putInt(key: String, value: Int): SharedPreferences.Editor {
            modifiedData[key] = value
            sysEdit.putInt(key, value)
            return this
        }

        override fun putBoolean(key: String, value: Boolean): SharedPreferences.Editor {
            modifiedData[key] = value
            sysEdit.putBoolean(key, value)
            return this
        }

        override fun putStringSet(
            key: String,
            values: MutableSet<String>?
                ): SharedPreferences.Editor {
            modifiedData[key] = values
            sysEdit.putStringSet(key, values)
            return this
        }

        override fun putFloat(key: String, value: Float): SharedPreferences.Editor {
            modifiedData[key] = value
            sysEdit.putFloat(key, value)
            return this
        }

        override fun putString(key: String, value: String?): SharedPreferences.Editor {
            modifiedData[key] = value
            sysEdit.putString(key, value)
            return this
        }
    }
}
```

在 Application 和 BaseActivity 中重写 getSharedPreferences

```kotlin
override fun getSharedPreferences(name: String?, mode: Int): SharedPreferences {
    return NoMainThreadWriteSharedPreferences.getInstance(super.getSharedPreferences(name, mode), name!!)
}
```

#### 反射将 `QueueWork` 清空

### MMKV 替换 SP

## binder 调用 ANR

涉及到了 binder 通信的。

- 获取进程名，参考：[[多进程#获取进程名]]，减少 ANR 触发几率
- 判断 App 进程在前台
- 启动阶段广播
- 启动阶段 跨进程的 API
