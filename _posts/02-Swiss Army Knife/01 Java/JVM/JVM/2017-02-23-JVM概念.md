---
date_created: Friday, February 23rd 2017, 10:10:44 pm
date_updated: Thursday, January 30th 2025, 6:39:37 pm
title: JVM概念
author: hacket
categories:
  - Java&Kotlin
category: JVM
tags: [JVM]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-27 23:42
date updated: 2024-12-27 23:42
aliases: [JVM 基础]
linter-yaml-title-alias: JVM 基础
---

# JVM 基础

## JVM 概念

JVM 是 java 的核心，是 Java 可以一次编译到处运行的本质所在。<br>JVM 与操作系统的关系:<br>![2gcgx](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/2gcgx.png)<br>从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。

## JVM 的组成和运行原理

JVM 有多种实现，使用最广泛的是 Oracle 的 HotSpot JVM。

### JVM 在 JDK 中的位置

JDK 是 java 开发的必备工具箱，JDK 其中有一部分是 JRE，JRE 是 JAVA 运行环境，JVM 则是 JRE 最核心的部分。下图是 JDK Standard Edition 的组成图：<br>![02zlu](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/02zlu.png)<br>HotSpot 是 Oracle 关于 JVM 的商标，区别于 IBM，HP 等厂商开发的 JVM。`Java HotSpot Client VM` 和 `Java HotSpot Server VM` 是 JDK 关于 JVM 的两种不同的实现，前者可以减少启动时间和内存占用，而后者则提供更加优秀的程序运行速度。

### JVM 组成

JVM 由四大部分组成：ClassLoader，Runtime Data Area，Execution Engine，Native interface。<br>![jsm5v](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/oh43j.png)

#### ClassLoader 类加载器

ClassLoader 是负责加载 class 文件。class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。

#### Native Interface 本地接口

Native Interface 是负责调用本地接口的。它的作用是调用不同语言的接口给 Java 用，它会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib。原本多于用一些专业领域，如 JAVA 驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于 Socket 通信，WebService 等方式取代。

#### Execution Engine 执行引擎

Execution Engine 是执行引擎，也叫 Interpreter。class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统。

#### Runtime Data Area 运行时数据区

Runtime Data Area 是存放数据的。分为五部分：Stack、Heap、Method Area、PC Register、Native Method Stack。几乎所有的关于 Java 内存方面的问题，都是集中在这块。<br>具体参考：`JVM Runtime Data Area.md`<br>![x12c2](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/x12c2.png)

## JVM 运行原理简介

Java 程序被 javac 工具编译成.class 字节码文件后，我们执行 java 命令，该 class 文件便被 JVM 的 ClassLoader 加载。可以看出 JVM 的启动是通过 JAVA Path 下的 java.exe 或者 java 进行的。JVM 的初始化、运行到结束大概包括这么几步：<br>调用操作系统 API 判断系统的 CPU 架构，根据对应 CPU 类型寻找位于 JRE 目录下的/lib/jvm.cfg 文件，然后通过该配置文件找到对应的 jvm.dll 文件（如果我们参数中有 -server 或者 -client，则加载对应参数所指定的 jvm.dll，启动指定类型的 JVM），初始化 jvm.dll 并且挂接到 JNIENV 结构的实例上，之后就可以通过 JNIENV 实例装载并且处理 class 文件了。class 文件是字节码文件，它按照 JVM 的规范，定义了变量，方法等的详细信息，JVM 管理并且分配对应的内存来执行程序，同时管理垃圾回收。直到程序结束，一种情况是 JVM 的所有非守护线程停止，一种情况是程序调用 System.exit()，JVM 的生命周期也结束。

## JVM 学习类图

- 「深入理解 Java 虚拟机:JVM 高级特性与最佳实践 (第 2 版)」时记录的笔记<br> ![79aut](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/79aut.png)
- 实战 JVM 虚拟机

![3hjlo](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/3hjlo.jpg)

![nb2eu](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/nb2eu.png)
