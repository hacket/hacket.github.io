---
date_created: Friday, February 23rd 2018, 10:10:44 pm
date_updated: Friday, January 31st 2025, 7:27:55 pm
title: Linux进程
author: hacket
categories:
  - 计算机基础
category: Linux
tags: [Linux, 操作系统]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:14
date updated: 2024-12-24 00:14
aliases: [Linux 进程]
linter-yaml-title-alias: Linux 进程
---

# Linux 进程

## 子进程与父进程的区别

1. 除了文件锁以外,其他的锁都会被继承
2. 各自的进程 ID 和父进程 ID 不同
3. 子进程的未决告警被清除；
4. 子进程的未决信号集设置为空集。

## fork 写时拷贝

Linux 的 fork() 使用是通过写时拷贝 (copyon-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需<br />要写入的时候才会进行，在此之前，只有以只读方式共享。

## 孤儿进程、僵尸进程

fork 系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子<br />进程的父进程将变为 init 进程（托孤给了 init 进程）。（注：任何一个进程都必须有父进程）如果子进程<br />先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这<br />个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）

## 多线程进程的 fork

在 POSIX 标准中，fork 的行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 的策略，<br />所以可以实现的速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别<br />的线程，到了子进程中都是突然蒸发掉的

> 假设这么一个环境，在 fork 之前，有一个子线程 lock 了某个锁，获得了对锁的所有权。fork 以<br />后，在子进程中，所有的额外线程都人间蒸发了。而锁却被正常复制了，在子进程看来，这个锁没<br />有主人，所以没有任何人可以对它解锁。当子进程想 lock 这个锁时，不再有任何手段可以解开<br />了。程序发生死锁
