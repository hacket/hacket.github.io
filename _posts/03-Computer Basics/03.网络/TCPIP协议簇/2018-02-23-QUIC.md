---
date_created: Friday, February 23rd 2018, 10:10:44 pm
date_updated: Friday, January 31st 2025, 9:54:26 pm
title: QUIC
author: hacket
categories:
  - 计算机基础
category: 网络协议
tags: [TCP, 网络协议]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:15
date updated: 2024-12-24 00:15
aliases: [QUIC]
linter-yaml-title-alias: QUIC
---

# QUIC

## 什么是 QUIC？

QUIC(Quick UDP Internet Connections)，快速 UDP 网络连接。QUIC 由 Google 实现于 2013 年，是一种网络传输协议，旨在提升网络传输速度。2015 年，QUIC 被提交到 IETF，目标是成为下一代的正式网络规范，2018 年，HTTP over QUIC 被 IETF 重命名为 HTTP/3。<br />在 UDP 之上，**QUIC 实现了类似 TCP 的丢失重传机制**，QUIC 传输以数据包级报头发送，并对每个包增加了单调递增的数据包号来代表传输顺序，当检测到必要帧丢失时，QUIC 会将必要帧绑定到新数据包重发。QUIC 对报文头部和数据也都进行了加密，且建联时改进使用了 DH 密钥交换算法，在防劫持方面也具有一定优势。<br />QUIC 是在应用层实现的协议，可以很灵活的切换各种协议状态，而不需要在内核中增加 socket 的 netFamily 的族群，在传输层增加逻辑。<br />相较于传统的 HTTP + TCP，**QUIC 还具有多项改进网络传输的优势**，其部分优势如图 2 所示。

![d4jxu](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/d4jxu.png)

**QUIC 目前分为 gQUIC 与 iQUIC 两种**，gQUIC 即为最初的 Google QUIC，而 iQUIC 是后来 IETF 制定的通用传输协议是提供给 HTTP3 的，gQUIC 应用更广泛。<br />相较 iQUIC 而言，gQUIC 目前的应用较为普遍、成熟，如 Cadddy 支持 gQUIC，客户端还有 Chromium 的 Net 库 Cronet 也可以支持 gQUIC，包括 ExoPlayer 等三方库也都提供了对于 gQUIC 的扩展支持。目前来看，**选择 gQUIC 对于渴望改善网络传输情况的开发者来说，在接入成本和接入效率上具有优势**。

## QUIC 特性

### 实现了类似 TCP 的流量控制、传输可靠性的功能

UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础上增加了一层来保证数据可靠性传输，它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。<br />QUIC 协议的改进：

- 可插拔 应用程序层面就能实现不同的拥塞控制算法
- 单调递增的 Packet Number 使用 Packet Number 替代了 TCP 的 seq
- 不允许 Reneging 一个 Packet 只要被 ACK，就认为它一定被正确接收
- 前向纠错（FEC）
- 更多的 ACK 块和增加 ACK Delay 时间
- 基于 Stream 和 Connection 级别的流量控制

### 实现了 0-RTT 快速握手功能

由于 QUIC 是基于 UDP 协议的，根本就不需要握手和挥手。所以 QUIC 可以实现使用 0-RTT 或 1-RTT 来建立连接。QUIC 可以用更快的速度来发送和接收数据，可以大大提高首次打开页面的速度。**0-RTT 建立连接可以说是 QUIC 相比 HTTP2 最大的性能优势**。

### 集成了 TLS 功能

目前 QUIC 使用的是 TLS1.3，相比较于早期版本的 TLS1.3 有更多的优点，最重要的一点是减少了握手所花费的 RTT 个数。<br />在完全握手情况下，需要 1-RTT 建立连接，TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。但是 TLS1.3 的 0-RTT 无法保证前向安全性 (Forward secrecy)，要缓解该问题可以通过设置使得与 SessionTicket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）

### 无对头阻塞的多路复用，彻底解决 TCP 队头阻塞的问题

和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

![2ylsp](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/2ylsp.png)

### 连接迁移

TCP 用四元组（客户端 IP、端口、服务器 IP、端口）确定一个连接，而 QUIC 是让客户端生成一个 ConnectionID(64 位) 来区别不同连接，只要 ConnectionID 不变，连接就不需要重新建立连接，即便是客户端的网络发生变化（比如客户端从 WIFI 切换到蜂窝网络）。由于连接迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。

![773gt](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/773gt.png)

### 全应用态协议栈

QUIC 核心逻辑都在用户态，能灵活的修改连接参数、替换拥塞算法、更改传输行为。而 TCP 核心实现在内核态，改造需要修改内核并且进行系统重启，成本极高。

## QUIC 接入

自研支持 quic 的库，使用三方库

### cronet

# HTTP3

Google 在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的 QUIC 协议，让 HTTP 跑在 QUIC 上而不是 TCP 上，这个 `HTTP over QUIC` 就是 HTTP3，在 HTTP2 的基础上又实现了质的飞跃，真正完美地解决了队头阻塞问题。<br />![8hdi5](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/8hdi5.webp)

# Ref

- [ ] [网易新闻QUIC敏捷实践](https://mp.weixin.qq.com/s/MUCSsgLbn3XBz7jgmdWk6Q)
- [ ] [弱网不弱-TQUIC助力业务提速30%](https://zhuanlan.zhihu.com/p/438920906)
