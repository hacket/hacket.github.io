---
date created: 2024-12-24 00:15
date updated: 2024-12-24 00:15
dg-publish: true
---

# TCP/IP

## 网络分层（TCP/IP四层模型 vs OSI七层模型）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/694278/1673714393984-c1417523-8aa5-4c9f-a0a3-d4d6d64c90be.png#averageHue=%23f6f5f5&clientId=u581a1d51-a7ca-4&from=paste&height=416&id=u340ae1d1&originHeight=624&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141686&status=done&style=none&taskId=ud53c4688-51d0-4795-a63d-6042ad9807b&title=&width=441.3333333333333)

## 什么是TCP/IP？

TCP/IP一般指的是TCP/IP协议簇<br />TCP：Transmission Control Protocol翻译过来就是传输控制协议，TCP协议是一个面向连接的、可靠的、基于字节流的传输层协议

## TCP、UDP 传输有什么区别？如何优化 UDP 传输？UDP 传输的数据包与 TCP 传输的数据包有什么区别？

### 1、TCP和UDP概念和特点

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 <br />TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。<br />UDP的优点： 快，比TCP稍安全，UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… <br />UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

### 2、TCP和UDP区别？

![image.png](https://cdn.nlark.com/yuque/0/2022/png/694278/1653664492020-b73b39b4-8ce6-4e93-83a7-304b3fdc3c36.png#averageHue=%23fdfcee&clientId=u7d7a6a49-7b9d-4&from=paste&height=266&id=taZUs&originHeight=399&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32459&status=done&style=none&taskId=u56e1abe8-e3d0-404b-9893-1e9ab0dfda2&title=&width=692)

- TCP是面向连接的，TCP传输数据之前需要三次握手；UDP是面向无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务（TCP连接传输的数据，无差错，不丢失，不重复，按序列到达）；UDP尽最大努力交付，即不保证可靠交付
- TCP面向字节流，实际上TCP把数据看成一连串无结构的字节流；UDP是面向报文的
- UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速度降低（对实时应用很有用，如IP电话、实时视频会议等）
- 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP首部开销20字节；UDP的首部开销小，只有8字节
- TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道

### 3、UDP存在的问题？怎么优化？

一是数据包容易丢失，二是数据包**无序 **

### 4、TCP和UDP报文结构

```java
源端口 16位
目标端口 16位
序列号 32位
回应序号 32位
TCP头长度 4位
reserved 6位
控制代码 6位
窗口大小 16位
偏移量 16位
校验和 16位
选项  32位(可选)
```

```java
源端口 16位
目的端口 16位
长度 16位
校验和 16位
```

## TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？

这两个完全是两样不同东西，实现的层面也不同：

- HTTP 的 keep-alive，是由**应用层（用户态）** 实现的，称为 HTTP 长连接；一个TCP连接多次使用
- TCP 的 keep-alive，是由 **TCP 层（内核态）** 实现的，称为 TCP 保活机制；TCP的keep-alive仅仅是为了维持连接的正常，保证连接不被断开，因此TCP会间隔的发送数据包检测是否连接正常，这个间隔的时间就是“keep-alive”的作用。

> 阿里一面：TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？
> <https://zhuanlan.zhihu.com/p/479813348>

## TCP拥塞？TCP拥塞控制原理？

TCP拥塞的背景：TCP/IP协议栈开始广泛运行是，网络开始遭受拥塞崩溃：即数据发送主机会以建议允许的速度将其数据包发送到互联网，当某些路由器发生拥塞，导致数据包被丢弃；对于TCP这种有重传机制的传输协议，当发生数据丢失时，重传数据将延长数据到达的时间；同时，高频率的重传，也将导致网络的拥塞得不到缓解，从而引发更多的拥塞<br />TCP拥塞控制：让每个源确定网络中有多少可用容量，以便它知道可以安全传输多少数据包，防止过多的数据注入到网络中，使网络中的路由或链路不至于过载。在网络中发生拥塞时，拥塞控制减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素<br />几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。

## 报文结构与 http 有什么不同？

## TCP粘包

## TCP是怎么保证可靠传输的？

**什么是可靠传输？**<br />可靠传输就是保证接收方收到的字节流和发送方发出的字节流是完全一样的<br />**TCP如何保证可靠性的？**<br />网络层是没有可靠传输机制的，尽自己最大的努力进行交付。而传输层使用 TCP 实现可靠传输，TCP 保证可靠传输的机制有如下几种：

1. 校验和 Checksum（稍作了解即可）

> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

2. **序列号和确认应答机制**（重要）

> TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

3. **重传机制**（重要）

> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

4. **流量控制**（滑动窗口协议）（非常重要）

> 流量控制指的是让发送方发送速率不要太快；TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用**滑动窗口**实现流量控制）

5. **拥塞控制**（重要）

> 当网络拥塞时，减少数据的发送。不同于流量控制考虑的是点对点的通信量控制，拥塞控制考虑的是整个网络，是一个全局性的考虑。
> 拥塞控制算法：
>
> - 慢启动
> - 拥塞避免算法

6. 数据合理分片与排序

> TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。

## TCP三次握手和四次挥手

[关于 TCP 三次握手和四次挥手，满分回答在此](https://mp.weixin.qq.com/s/u56NcMs68sgi6uDpzJ61yw)

### 重要标志位

1. ACK：Acknowledge Character，确认字符 TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
2. SYN：Synchronize Sequence Numbers，同步序列编号，在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1，因此SYN置1就表示这是一个连接请求或连接接受报文
3. FIN: Finish 终结，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

> SEQ：Sequence Number，序列号

### 三次握手

TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包，1.5RTT。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/694278/1655912814339-63873653-5547-4b07-8bd3-f309d345d4cb.png#averageHue=%23f7f2ec&clientId=u63b06394-2e18-4&from=paste&height=397&id=u0920f673&originHeight=563&originWidth=887&originalType=url&ratio=1&rotation=0&showTitle=false&size=71534&status=done&style=none&taskId=u870d9203-9890-4b86-8c85-b9b7a4653cb&title=&width=625)

1. **第一次握手：建立连接**。客户端发送连接请求报文段，将SYN位置为1且seq为x；然后客户端进入SYN_SEND状态，等待服务器确认；即A发送信息给B。
2. **第二次握手：服务器B收到SYN报文段**。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，（ACK=x+1），同时自己也发送一个SYN=1报文（seq=y），即SYN+ACK报文，此时服务器B进入SYN_RECV状态。
3. **第三次握手：客户端A收到服务器B的SYN＋ACK报文段**。客户端A向服务器B发送报文段ACK（ACK=y+1），此报文段发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。客户端与服务器开始传送数据。

> TCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起TCP的连接关系。

### 四次挥手

![](https://cdn.nlark.com/yuque/0/2023/webp/694278/1673539795930-55bd2170-4d58-4034-89d6-f5946ac6d641.webp#averageHue=%23e0dfde&clientId=u2123e26d-9d73-4&from=paste&height=458&id=ucfbe6269&originHeight=556&originWidth=666&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7e7409d6-9434-4d57-8566-f126505381d&title=&width=549)

1. **客户端发送FIN释放连接请求报文**，用来关闭客户端到服务器的数据传送（Client发送释放信息给Server，发出去之后，Client→Server发送数据这条路径就断了）
2. **服务器收到这个FIN并确认**，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号（Server收到Client的释放信息之后，回复确认释放的信息，Server同意Client的释放连接请求）
3. **服务器发送关闭与客户端的连接请求报文**，发送一个FIN给客户端（Server发送请求释放连接信息给Client）
4. **客户端发送ACK报文确认**，并将确认序号设置为收到序号加1（Client收到Server发送的信息后向Server发送确认释放信息，Client同意Server的释放连接请求，Server收到确认信息后就会正式关闭连接；Client等待2MSL后依然没有收到回复，则证明Server已正常关闭，于是Client关闭连接）

### TCP为什么是3次握手？不是2次，不是4次？

- [ ] [TCP 为什么三次握手而不是两次握手（正解版）](https://blog.csdn.net/lengxiao1993/article/details/82771768)
- [ ] [淘宝二面，面试官居然把TCP三次握手问的这么详细](https://www.eet-china.com/mp/a44399.html)

我们可以从几个方面来解释：

#### 1、确认双方的收发能力

TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。<br />   1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

所以，只有三次握手才能确认双方的接收与发送能力是否正常

#### 2、序列号可靠同步

如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。

#### 3、阻止重复历史连接的初始化

客户端由于某种原因发送了两个不同序号的 SYN 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 SYN 就会立刻建立连接，那么会造成网络异常。<br />如果是三次握手，服务器需要回复 SYN+ACK 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 RST 报文，直到正常的 SYN 到达服务器后才正常建立连接。<br />所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。

#### 4、安全问题

我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。<br />TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！

### TCP 为什么需要握手这个操作？

**原因：** TCP 是可靠通信协议， 全双工，为保证传输的可靠性，需要给每次传输的数据段添加序号，那么初始的序列号就是TCP三次握手真正的意义所在，而为了确保交换双方的初始序号，最少需要三次才行。<br />**前两次握手**<br />为了保证服务端能接收到客户端的信息并能做出正确的应答而进行前两次握手。<br />**后两次握手**<br />为了保证客户端能接收到服务端的信息并能做出正确的应答而进行的后两次握手。

### TCP挥手的目的

为了保证双方都能通知对方需要释放连接，即在释放连接后都无法接收或发消息给对方。

### TCP第四次握手时，为什么要等待 2 MILS？

1. 确保客户端发送的第四次ack报文服务器能收到（因为最后一次挥手报文没有确认，我们需要确保Client的ACK可以到达Server，如果2MSL时间内没有收到，则Server会重发）
2. 2MSL时间可以保证当Server没有收到确认时，Server可以再次发送FIN报文，并且Client可以再次收到并重新发送确认，所以2MSL的时间可以保证连接正常结束
3. 确保当前连接的所有报文都已经过期，防止旧数据滞留网络，影响新的连接

## Socket

### 什么是Socket？

Socket(套接字)是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远端主机的IP地址，远端进程的协议端口。

### Socket断线重连实现

正常连接断开客户端会给服务器发送一个FIN报文，服务器收到FIN后才会知道连接断开。而断网断电等异常情况客户端无法发送FIN给服务器，所以服务器没法检测到客户端已经断线。<br />为了缓解这个问题，服务器需要有个心跳机制，就是服务端检测到某个客户端多久没发送任何数据过来就认为客户端已经断开，这需要客户端定时向服务器发送心跳数据来维持连接不断开。

### 心跳机制

**什么是长连接？**<br />长连接是建立连接之后，不主动断开，双方互相发送数据，发完了也不主动断开连接，之后有需要发送的数据就继续通过这个连接发送。<br />**为什么需要心跳？**<br />主要是为了防止NAT超时，客户端隔一段时间就主动发一个数据，探测连接是否断开。

> 移动网络并不在Internet中，而是在运营商的内网，并不具备真正的公网IP，因此当某个TCP连接在一段时间不通信之后，网关会出于网络性能的考虑而关闭这条TCP连接和公网的连接通道，导致这个TCP端口不再收到外部通信消息，即TCP连接被动关闭。

在一定间隔时间内，使用TCP连接发送超短无意义的消息来让网关不能将自己定义为空闲连接，从而防止网关将自己的连接关闭。<br />**服务器如何处理心跳包？**<br />假如客户端心跳间隔是固定的，那么服务器在连接闲置超过这个时间还没收到心跳时，可以认为对方掉线，就可以关闭连接；如果客户端心跳会动态变动，应当设置一个最大值，超过这个最大值才认为对方掉线；还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时，可以直接认为对方掉线。

## WebSocket

### HTTP与WebSocket区别与联系

1. Http与WebSocket是两个完全不同的协议，都是基于TCP的。两者唯一的联系是WebSocket利用HTTP进行握手；具体说明请看RFC6455-1.7。
2. WS默认也使用80端口；WSS默认也使用443端口。当然如果这个也算是和HTTP的联系的话，那么你说的也对。
3. HTTP协议局限性一大堆，比如明文传输、无法保证信息完整性、没有身份验证等。而WebSocket的出现则是为了解决HTTP协议只能由Client发起通信请求的问题。WebSocket是全双工通信。

# IP报文

## IP报文作用

1. IP协议使得复杂的实际网络变为一个虚拟互连的网络
2. IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发
3. IP协议解决了虚拟网络中数据包传输路径的问题

# 面试题

## TCP和Socket关系？

## HTTPS 中TLS和TCP能同时握手吗？

不能，先TCP的3次握手建立TCP连接，再是TLS握手

## 如何设计在UDP上层保证UDP的可靠性传输？

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现方式可以参照TCP可靠性传输的方式：

1. 添加seq/ack机制，确保数据发送到对端
2. 添加发送和接收缓冲区，主要是用于添加超时重传机制

# Ref

- [ ] [TCP协议灵魂之问，巩固你的网路底层基础](https://juejin.cn/post/6844904070889603085)
