---
date_created: Friday, January 31st 2015, 9:49:59 am
date_updated: Friday, January 31st 2025, 10:22:35 am
title: 05 Hash 哈希
author: hacket
categories:
  - 数据结构和算法
category: 基础
tags: [哈希, 数据结构和算法]
toc: true
description: 
dg-publish: true
dg-enable-search: true
dg-show-local-graph: true
dg-show-toc: true
dg-show-file-tree: true
image-auto-upload: true
feed: show
format: list
date created: 2024-12-24 00:19
date updated: 2024-12-24 00:19
aliases: [Hash 哈希\散列]
linter-yaml-title-alias: Hash 哈希\散列
---

# Hash 哈希\散列

## 散列函数 Hash function

**散列函数**（英语：Hash function）又称 `散列算法`、`哈希函数`，是一种从任何一种数据中创建小的数字 " 指纹 " 的方法。散列函数把消息或数据计算成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（又叫哈希值）（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。如果在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

如今，散列算法也被用来加密存在数据库中的密码（password）字符串，由于散列算法所计算出来的散列值（Hash Value）具有不可逆（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。

wiki 定义：[散列函數](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)

## 散列函数的性质

所有散列函数都有如下一个基本特性：**如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的**。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为 `单向散列函数`。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为 "`散列碰撞（collision）`"，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。

典型的散列函数都有非常大的定义域，比如 `SHA-2` 最高接受 `(264-1)/8` 长度的字节字符串。同时散列函数一定有着有限的值域，比如固定长度的比特串。在某些情况下，散列函数可以设计成具有相同大小的定义域和值域间的单射。在密码学中，散列函数必须具有不可逆性。

散列函数运作的例子：

![image.png](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20250131094849.png)

## 散列函数的应用

### 散列表

**散列表**是散列函数的一个主要应用，使用散列表能够快速的按照**关键字**查找数据记录。（注意：关键字不是像在加密中所使用的那样是秘密的，但它们都是**用来 " 解锁 " 或者访问数据的**）。

举个英文字典的例子，开头相同字母对应多个单词，相同字母越多（规则越严格），匹配结果越少（冲突越少）。

一个**好的散列函数**具有**均匀的真正随机输出**，因而平均只需要一两次探测（依赖于装填因子）就能找到目标。同样重要的是，随机散列函数不太会出现非常高的冲突率。但是，**少量的可以估计的冲突**在实际状况下是**不可避免**的（参考 [生日悖论](https://en.wikipedia.org/wiki/Birthday_problem) 或 [鸽巢原理](https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86)）。

# 哈希表 leetcode 题

## 两数之和

## 两数之和 + 元素可重复哈希表的实现

## 两数之和各种变种？
