---
date created: 2022-04-20 15:40
date updated: 2025-01-02 15:37
dg-publish: true
tags:
  - '#include'
image-auto-upload: true
feed: show
format: list
---

# VSCode 配置 C++环境（Mac）

## 安装插件

1. 安装 VS Code
2. 安装扩展
   1. `C/C++`
   2. `CodeLLDB`

![image.png|300](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240404001135.png)

> CodeLLDB 可能由于网络问题安装不成功，可手动下载
> 打开 Github：[https://github.com/vadimcn/vscode-lldb/releases](https://link.zhihu.com/?target=https%3A//github.com/vadimcn/vscode-lldb/releases)，打开之后根据你的电脑芯片下载对应的版本

如果是基于 Intel 的 Mac 选择 `codelldb-×86_64-darwin.vsix`，

> 如果是基于 Apple Silicon 的 Mac 选择 `codelldb-aarch64-darwin.vsix`

下载完成后，在扩展中点击从 vsix 中安装，即可。
![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240404001255.png)

## 配置编译器和调试环境

安装 C/C++ 编译器和调试工具：

- 如果您在 Windows 上，可能需要安装 Build Tools for Visual Studio。
- 在 Linux 或 macOS 上，需要安装 `GCC` 或 `Clang` 编译器以及 `GDB` 或 `LLDB` 调试器。

安装后，在终端中运行 `gcc --version`（或 `clang --version`）以及 `gdb --version`（或 `lldb --version`）以确认安装成功。
![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420160453.png)
如果 `Clang` 没有安装：

```shell
xcode-select --install
```

## 配置 VSCode 项目

在 VSCode 中打开您的工作区：

- 对于单文件的 C/C++ 程序，只需创建一个 `.cpp` 文件就可以开始。
- 对于多文件或项目，您应该创建一个包含所有相关源码文件的文件夹作为工作区。

## Explore IntelliSense 代码提示

默认就是开启的，按 `Tab` 补全，如果没有开启，按下面步骤：

1. open the Command Palette (`⇧⌘P`)
2. **Select IntelliSense Configuration**，select `Use clang++`

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420162958.png)
![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420163037.png)

## Run Code

- `Run C/C++ File`

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420163733.png)

- 选择编译器：**C/C++: clang++ build and debug active file**

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420164010.png)
然后在 `.vscode` 目录生成 `task.json` 文件：

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang++ build active file",
            "command": "/usr/bin/clang++",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

- 编译成功后，Console 输出产物

![image.png|1200](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420164441.png)

## `task.json` 配置

第一次运行程序时，C++ 扩展会创建 `tasks.json` ，位于项目的 `.vscode` 文件夹中。 `tasks.json` 存储构建配置。以下是 macOS 上 `tasks.json` 文件的示例：

**`task.json` 文件用于配置任务，它定义了执行特定操作的任务，并提供了相应的命令和参数。**

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang++ build active file",
            "command": "/usr/bin/clang++",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

> 注意，`task.json` 中可能用到的变量：[variables reference](https://code.visualstudio.com/docs/editor/variables-reference).

- **command** `command` 设置指定要运行的程序。在本例中，即 `clang++` 。
- **args** `args` 数组指定传递给 `clang++` 的命令行参数。这些参数必须按照编译器期望的顺序指定。

此任务告诉 C++ 编译器获取活动文件 (`${file}`)，对其进行编译，并在当前目录 ( `${fileDirname}` ）。此过程创建 `helloworld` 。

- **label** `label` 值是您在任务列表中看到的值，这取决于您的个人偏好。
- **detail** `detail` 值是任务列表中任务的描述。更新此字符串以将其与类似任务区分开。
- **problemMatcher** `problemMatcher` 值选择用于查找编译器输出中的错误和警告的输出解析器。对于 `clang++`， `$gcc` 问题匹配器会创建最佳结果。
- **group**

从现在开始，播放按钮始终从 `tasks.json` 读取，以确定如何构建和运行程序。您可以在 `tasks.json` 中定义多个构建任务，并且标记为默认的任务就是播放按钮使用的任务。如果您需要更改默认编译器，可以运行“任务：命令面板中的配置默认构建任务”。或者，您可以修改 `tasks.json` 文件并通过替换此段来删除默认值：

```json
"group": {
	"kind": "build",
	"isDefault": true
},
```

设置编译不支持 `C++11` 及以后的标准，配置 `task.json`

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ 生成活动文件",
            "command": "/usr/bin/g++",
            "args": [
                "-std=c++17",
                "-stdlib=libc++",
                "-fdiagnostics-color=always",
                "-g",
                "-Wall",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}
```

示例：

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main()
{
    int b = 1;
    auto a = b;
    cout << a << endl;
    vector<string> msg{"Hello", "C++", "World", "from", "VS Code", "and the C++ extension!"};
    int len = msg.size();
    cout << "长度" << len << endl;
    for (int i = 0; i < 5; i++)
    {
        // ms.push_back("a");
        cout << i << endl;
    }

    return 0;
}
```

### 修改 `task.json` 以支持多个 `.cpp`

- 您可以使用 `"${workspaceFolder}/*.cpp"` 等参数而不是 `"${file}"` 来修改 `tasks.json` 以构建多个 C++ 文件。这将构建当前文件夹中的所有 `.cpp` 文件。
- 您还可以通过将 `"${fileDirname}/${fileBasenameNoExtension}"` 替换为硬编码文件名（例如 `"${workspaceFolder}/myProgram.out"` ）来修改输出文件名。

```json
// 支持多个cpp文件
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang++ build active file",
            "command": "/usr/bin/clang++",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                // "${workspaceFolder}/*.cpp",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}/bin/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

## Debug 代码

- 返回到 `helloworld.cpp` ，使其成为活动文件。
- 通过单击编辑器边距或在当前行上使用 `F9` 设置断点，从播放按钮旁边的下拉列表中，选择“`Debug C/C++ File`”。。

![image.png|1000](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420170146.png)

- 从系统上检测到的编译器列表中选择 C/C++: clang++ 构建和调试活动文件（只有在第一次运行或调试 `helloworld.cpp` 时才会要求您选择编译器）。

![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420170238.png)

- 进入到了调试界面

![image.png|1000](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420170338.png)

### 如何 Debug

#### Debug 界面

![image.png|900](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420170722.png)

- 编辑器会突出显示您在启动调试器之前设置断点的行
- 活动栏中的“运行和调试”视图显示调试信息。
- 在代码编辑器的顶部，会出现一个调试控制面板。您可以通过抓住左侧的点在屏幕上移动它。<br> ![image.png|300](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420170759.png)

#### 单步执行代码

- 在调试控制面板中选择“单步执行”图标，以便突出显示 `for (const string& word : msg)` 语句

![image.png|300](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420171343.png)

#### 设置 watch

您可能希望在程序执行时跟踪变量的值。您可以通过对变量设置监视来做到这一点。

- 将插入点放置在循环内。在“监视”窗口中，选择加号并在文本框中键入 `word` 。这是循环变量的名称。现在，当您单步执行循环时，请查看“监视”窗口。

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420171610.png)

- 通过在循环之前添加以下语句来添加另一个监视： `int i = 0;` 。然后，在循环内添加以下语句： `++i;` 。现在，像上一步中一样添加 `i` 的监视。

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420171737.png)

- 要在执行暂停时快速查看任何变量的值，可以将鼠标指针悬停在该变量上。

### launch.json 配置

当您使用 `Run` 按钮或 `F5` 进行调试时，`C++扩展` 会动态创建动态调试配置。

在某些情况下，您需要自定义调试配置，例如指定在运行时传递给程序的参数。您可以在 `launch.json` 文件中定义自定义调试配置。

`launch.json` 文件用于配置`调试器`，它定义了调试会话的启动方式以及各种调试选项。

要创建 `launch.json` ，请从播放按钮下拉菜单中选择“`添加调试配置`”，
![image.png|300](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420173853.png)
或者：
![image.png|400](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240404001424.png)
然后，您将看到各种预定义调试配置的下拉列表。选择 `C/C++：clang++` 构建并调试活动文件。
![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420173928.png)
VS Code 创建一个 `launch.json` 文件，如下所示：

```json
{
  "configurations": [
    {
      "name": "C/C++: clang++ build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/bin/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${fileDirname}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "lldb",
      "preLaunchTask": "C/C++: clang++ build active file"
    }
  ],
  "version": "2.0.0"
}
```

- `"configurations"`：包含了一个或多个调试配置，每个配置定义了一个特定的调试方案。
- `"type"`：指定了要使用的调试器类型，如 `C++`、`Python`、`Node.js` 等。
- `"request"`：指定了调试器的请求类型，例如 `"launch"`、`"attach"` 等。
- `"program"`：指定了要调试的程序的入口点路径。此处设置为活动文件夹 `${fileDirname}` 和活动文件名 `${fileBasenameNoExtension}` ，如果 `helloworld.cpp` 是活动文件，则为 `helloworld` 。 `args` 属性是在运行时传递给程序的参数数组。
- `"args"`：指定了传递给被调试程序的命令行参数。
- `environment`：指定了环境变量，用于设置调试过程中的环境。
- `stopAtEntry`：默认情况下，C++ 扩展不会向源代码添加任何断点，并且 `stopAtEntry` 值设置为 `false` 。将 `stopAtEntry` 值更改为 `true` 以使调试器在开始调试时停止在 `main` 方法上。
- `preLaunchTask`：确保 `preLaunchTask` 值与 `tasks.json` 文件中构建任务的 `label` 问题匹配器会创建最佳结果。

从现在开始，在启动程序进行调试时，播放按钮和 F5 将从您的 `launch.json` 文件中读取。

**注意：请确保`launch.json` 中 `preLaunchTask` 的值和 `tasks.json` 中的 `label` 保持一致。**

## `c_cpp_properties.json` 配置

`c_cpp_properties.json` 中包含了编译器路径、头文件路径等等的设置信息，这些信息主要用于编辑的代码智能提示(IntelliSense)。
C++ 的语法提示、代码跳转等功能是 c++ 插件提供的，插件中有一套默认配置，无需用户自行设置。但如果有 diy 需要，就用得到 `c_cpp_properties.json` 文件了。

在 VSCode 中按下 `⇧⌘P`，输入命令 `C/C++: Edit Configurations (UI)` 打开 C/C++ 的配置页面。

![700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240404002111.png)

### C/C++ Configuration

这将打开 C/C++ 配置页面。

![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420174816.png)

根据 CPU 架构 (一般是 Intel 或 Apple Silicon) 和编译器 (Compiler path: Clang 或 GCC) 的不同，我们需要在配置页面中设置 `编译器路径` 和 `IntelliSense 模式` 这两个选项。

#### 编译器路径

从下拉框中选择 Clang/GCC 可执行文件对应的路径。

- Clang 的路径示例: `/usr/bin/clang` 或者 `/usr/bin/clang++`
- GCC 的路径示例: `/opt/homebrew/Cellar/gcc/12.2.0/bin/g++`

#### IntelliSense 模式

| CPU           | 编译器   | 选项                |
| ------------- | ----- | ----------------- |
| Intel         | Clang | macos-clang-x64   |
| Intel         | GCC   | macos-gcc-x64     |
| Apple Silicon | Clang | macos-clang-arm64 |
| Apple Silicon | GCC   | macos-gcc-arm64   |

### `launch.json`、`tasks.json` 和 `c_cpp_properties.json` 小结

- `tasks.json` -> `gcc`；`launch.json` -> `gdb`
- 启动`gdb`调试会话之前需要首先执行`gcc`编译任务。因此，`launch.json`有一条配置`preLaunchTask`，指向`tasks.json`中的编译任务(`label`)。其实有些人的配置无法运行的部分原因就是这个不一致。
- `c_cpp_properties.json` 这个文件主要是用于 VSCode 语法提示的配置，例如：指定 include 路径，问题匹配类型等。`Ctrl+Shift+P` 打开 `Command Palette`，找到并打开：`C/C++:Edit Configurations (UI)`。进行一些配置后，`.vscode` 文件夹下会自动生成此文件。这个配置不会影响到 gcc 编译命令，只是让你在编写代码时能有方法、变量等的语法提示。

### c_cpp_properties.json

在 C/C++ 的配置页面设置好之后，VSCode 会为我们自动生成 `.vscode/c_cpp_properties.json` 文件。

```json
{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [],
            "macFrameworkPath": [
                "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks"
            ],
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "macos-clang-arm64",
            "compilerPath": "/usr/bin/clang++"
        }
    ],
    "version": 4
}
```

有关 `c_cpp_properties.json` 的官方说明可以参考:
[c_cpp_properties.json reference](https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference)

## 问题

### 配置的 clang 不生效

![800](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/企业微信截图_2fde813b-a1b1-4938-a183-e556db719dad.png)
原因：配置了 `Code Runner` 插件，用的是 `g++`
![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian/20240420202613.png)

解决：把 `Code Runner` 插件 disable；不要用右键 `Run Code` 的功能

### Run C/C++ File 不允许

在 Mac 上，点击 Run 后，这是生成二进制，没有给我们运行二进制，我们可以自定义一个 Task。

在 Visual Studio Code（VS Code）中，没有内置的“编译和运行”按钮用于 C++ 程序。不过，您可以通过配置任务（Tasks）和拓展插件来实现类似的功能。有 2 种方式

#### VS Code 任务配置编译和运行按钮

- 在 `task.json` 中新增一个 task

```json
{
   "label": "Run Executable",
   "type": "shell",
   "command": "./${fileBasenameNoExtension}", // 注意修改成可运行的二进制的目录
   "group": {
	   "kind": "test",
	   "isDefault": true
   },
   "presentation": {
	   "reveal": "always"
   }
}
```

- 然后通过 `Ctrl+Shift+P`，Run task，运行该 Task

#### 使用 `Code Runner` 拓展插件

- 安装 Code Runner 插件：打开扩展视图（在侧边栏，或者按 `Ctrl+Shift+X`），搜索 Code Runner 插件并安装它。
- 插件安装完成后，您将在 VS Code 顶部的菜单栏看到一个小三角形运行图标，您可以通过点击它来运行当前代码。
- 如果您希望一键编译并运行 C++ 代码，您可以在 `settings.json` 中为 Code Runner 配置一些自定义的编译指令。例如：

```json
"code-runner.executorMap": {
	// ...
	"c": "cd $dir && gcc $fileName -o bin/$fileNameWithoutExt && bin/$dir$fileNameWithoutExt",
	"cpp": "cd $dir && g++ $fileName -o bin/$fileNameWithoutExt && bin/$dir$fileNameWithoutExt"
	// ...
}
```

上面我们在生成的二进制和执行的二进制命令前都加了 `bin` 目录

- 这样配置后，每当您点击 Code Runner 的运行按钮或者使用快捷键 `Ctrl+Alt+N` 时，它将编译当前的 .cpp 文件并立即运行产生的可执行文件。
- 另外，您也可以编辑 VS Code 中的 `keybindings.json` 文件来为编译和运行设置自定义快捷键。

# VSCode 配置 C/C++环境（Windows）

## 安装必须

1. VSCode
2. `C/C++` 插件

## Installing the `MinGW-w64 toolchain`

### 什么是 MinGW？

MinGW (Minimalist GNU for Windows) 是一个为 Windows 平台提供的 GNU 工具链的精简版本。它包括一套开源的编程工具，如 GCC (GNU 编译器集合)，它支持多种编程语言，包括 C、C++、Fortran 和其他语言。MinGW x 64 是这个工具链的 64 位版本，它允许开发者在 Windows 上创建原生的 Win 64 应用程序。

MinGW 提供了一个免费且简单的 GNU 工具集合，在不需要重写源代码的情况下支持跨平台的程序开发。它利用 Windows 的本地 Win 32 API，而不是为 POSIX 兼容层提供支持（比如 Cygwin）。因此，使用 MinGW 编译的程序性能往往更高，因为它直接和 Windows 操作系统的底层接口打交道。

简而言之，MinGW x 64 提供的主要功能包括：

1. `gcc`: GNU C 和 C++ 编译器。

2. `g++`: GNU C++ 编译器。

3. `gfortran`: GNU Fortran 编译器。

4. `binutils`: 一组二进制工具，包括链接器和资源编译器。

5. `MSYS`: 一个提供了 bash shell 和 Unix 风格构建工具的命令行环境。

6. `mingw-get`: 一个类似于 Linux 上的 apt-get 或 yum 的包管理器，用于安装、删除和更新 MinGW 工具和库。

### 安装 MinGW

- 安装 `MSYS2`：[**direct link to the installer**](https://github.com/msys2/msys2-installer/releases/download/2024-01-13/msys2-x86_64-20240113.exe)
- 然后安装 `MinGW-64`，打开刚刚安装的 `MSYS2`，输入下面命令：

```shell
pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain
```

- 默认按确认，中途输入 `Y`，安装所有

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202404212259411.png)

- 配置 path: `D:\msys64\ucrt64\bin`
- 校验 `MinGwx64` 是否安装和配置成功：

```shell
gcc --version
g++ --version
gdb --version
```

## 配置IntelliSense

- open the Command Palette (`Ctrl+Shift+P`)
- 选择：**Select IntelliSense Configuration**
- Use `gcc.exe`

## 配置 `task.json`

- Run C/C++ File

![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202404212304225.png)

- 选择编译器： **C/C++: g++.exe build and debug active file**

![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202404212249924.png)

- 然后在 `tasks.json` 创建一个配置：

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang++ build active file",
            "command": "/usr/bin/clang++",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}/bin/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": "build",
            "detail": "Task generated by Debugger."
        },
        {
            "type": "cppbuild",
            "label": "C/C++: g++.exe build active file",
            "command": "D:\\msys64\\ucrt64\\bin\\g++.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\\bin\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

上面有 2 个 task，第 1 个是 Mac 上配置的 `Clang++`，第 2 个是 Windows 配置的 `G++`

注意：修改了输出，加了 `\\bin` 目录，编译的 `exe` 在 bin 目录下。

### 配置支持多个 `cpp` 文件

修改 `task.json`，将 `${file}` 改成 `${fileDirname}/*.cpp`

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++.exe build active file",
            "command": "D:\\msys64\\ucrt64\\bin\\g++.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${fileDirname}/*.cpp",
                "-o",
                "${fileDirname}\\bin\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

## 配置 Debugger：`launch.json`

- 生成 `launc.json`

![image.png|700](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202404212310569.png)

- `launch.json` 文件

```json
{
    "configurations": [
        {
            "name": "C/C++: clang++ build and debug active file",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/bin/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "lldb",
            "preLaunchTask": "C/C++: clang++ build active file"
        },
        {
            "name": "C/C++: g++.exe build and debug active file",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}\\bin\\${fileBasenameNoExtension}.exe",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "miDebuggerPath": "D:\\msys64\\ucrt64\\bin\\gdb.exe",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "C/C++: g++.exe build active file"
        }
    ],
    "version": "2.0.0"
}
```

# VSCode 中配置 CMake

[Get started with CMake Tools on Linux](https://code.visualstudio.com/docs/cpp/CMake-linux)

## 必要工具安装

- 安装 CMake
- **VSCode CMake 插件**：要功能是CMake语法高亮、自动补全
- **VSCode CMake Tools 插件**：CMake Tools 插件提供了更高级的集成和工具，使得在 VSCode 中配置、构建、测试和调试基于 CMake 的项目变得简单
- `MINGW（Windows）`，Mac 上安装 `Clang`
- `macro-commander`: 组合 vscode 命令的插件，可选

检测 CMake 安装是否成功：

```shell
cmake --version
```

检查 MINGW/Clang 是否安装成功：

```shell
gcc -v
```

## CMake hello world

- Open the Command Palette (`Ctrl+Shift+P`) and run the **CMake: Quick Start** command:

![|300](https://code.visualstudio.com/assets/docs/cpp/cpp/cmake-quickstart-command-palette.png)

- 选择**Executable**或者 `Library`
- 创建一个 `main.cpp`, `CMakeLists.txt` 和 `build` 目录

### Select a kit

- Open the Command Palette (`Ctrl+Shift+P`) and run **CMake: Select a Kit**
- 选择 `GCC`

![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405020112476.png)

### Configure Hello World

配置好后，会生成 `main.cpp` 和 `CMakeLists.txt` 2 个文件

切换到 Cmake 视图，可以在这配置 Build/Debug/Launch 等
![image.png|400](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405020114511.png)
也会在 `./vscode/settins.json` 目录生成 CMake 相关的配置：

```json
{
	"cmake.sourceDirectory": "F:/C++/Workspace/VSCpp/C++/CMake",
	"cmake.cacheInit": null
}
```

- CMake 的 `cmake.sourceDirectory` 配置变量一般是用于指定单个源代码目录的，也就是包含项目顶层 CMakeLists. Txt 文件的目录。它用于告诉 CMake 从哪个目录开始运行 CMake 脚本。
- `cmake.sourceDirectory` 改变后需要删除 `build/` 目录重新构建

### Build hello world 和 Run

**状态栏 build，Debug 和 Run：**
![image.png|500](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405020128228.png)

还可以通过 `PROJECT OUTLINE`：
![image.png|400](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405031130179.png)

### 配置 CMake 的 gitignore

```shell
# Exclude build directory  
build/  
  
# Exclude CMake temporary files  
CMakeCache.txt  
CMakeFiles/  
cmake_install.cmake  
Makefile  
*.make  
  
# Exclude files generated by CTest  
CTestTestfile.cmake  
Testing/  
  
# Exclude IDE and editor files  
.idea/  
*.code-workspace  
.vscode/  
*.sublime-workspace  
  
# Exclude user-specific files  
*.user  
*.user.*  
  
# Exclude system-specific files  
*.suo  
*.ncb
```

### Ref

- [VSCode与CMake搭配使用之基本配置 - EdgeAI Lab](https://edgeai-lab.github.io/notebook/Embedded%20System/linux/compiler/cmake/vscode_cmake_base/)

## 多个源文件配置

**VSCode结合Cmake开发编译程序时的步骤：**

- 在各个子文件目录下创建 `CMakeLists.txt` 文件
- 首先 `Ctrl+Shift+P` 调出快捷输入窗
- 使用 `CMake Config` 配置后，选择电脑上安装好的编译器进行编译。
- 使用 `CMake Build`，自动生成外部构建的 build 文件夹。
- 使用 `CMake Debug`，进行程序代码调试。

**目录结构如下：**
![image.png|200](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405021229197.png)

`.vscode/settings.json` 配置：

````json
```json
{
	"cmake.sourceDirectory": "F:/C++/Workspace/VSCpp/C++/CMake",
	"cmake.cacheInit": null
}
````

**F:/C++/Workspace/VSCpp/C++/CMake 根目录 CMakeLists.txt 配置：**

```cpp
cmake_minimum_required(VERSION 3.5)
add_subdirectory(lesson1_1/)
add_subdirectory(lesson1_2/)
add_subdirectory(CMakeHelloWorld/)
```

看一个 `lesson_1` 的配置，其他的都类似：

```cpp
add_executable(lesson1_1_exe "main.cpp" "add.cpp")
```

**CMake 视图：**

![image.png|200](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405021236535.png)

**VSCode 底部状态栏快捷的 CMake 命令启动：**
![image.png|200](https://raw.githubusercontent.com/hacket/ObsidianOSS/master/obsidian202405021236145.png)

## `cmake.sourceDirectory` 配置支持多平台

在 `.vscode/settings.json` 中，用 `${workspaceFolder}` 就可以配置在各个平台通用了

```json
"cmake.sourceDirectory": "${workspaceFolder}/C++/Singleton",
```

# Ref

- [Get Started with C++ and MinGW-w64 in Visual Studio Code](https://code.visualstudio.com/docs/cpp/config-mingw)
- [Configure VS Code for Clang/LLVM on macOS](https://code.visualstudio.com/docs/cpp/config-clang-mac)
- [Visual Studio Code Variables Reference](https://code.visualstudio.com/docs/editor/variables-reference)
- [Get started with CMake Tools on Linux](https://code.visualstudio.com/docs/cpp/CMake-linux)
